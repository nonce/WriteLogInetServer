/* This program is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
** PARTICULAR PURPOSE. */


#ifdef WIN32
#define WINVER 0x0501
#ifdef _DEBUG
#include <afx.h>	// this turns on memory tracking on the Win32 DEBUG build
#endif
#endif

#include <iostream>
#include <set>
#include <thread>
#include "ServerState.h"
#include "envH.h"
#include "C1Stub.h"
#include "C2Stub.h"


// These are the only source files 
// NOT generated by, or copied from, the gSOAP tools:
//    WritelogInetServer.cpp (this file)
//    C1impl.cpp
//    C2impl.cpp
//  The others are generated this way:
//
// pushd C1
//   gsoap-2.8\gsoap\bin\wsdl2h -o ../ContestQsos.h -ncontest -Ic:\dev\gsoap-2.8\gsoap\import ContestQsos.wsdl
//   cd ..\C2
//   gsoap-2.8\gsoap\bin\wsdl2h -o ../ContestQsos2.h -ncontest2 -Ic:\dev\gsoap-2.8\gsoap\import ContestQsos2.wsdl
//   popd
// soapcpp2 -L -S -IC:\dev\gsoap-2.8\gsoap\import -x -w -n -qC1 ContestQsos.h
// soapcpp2 -L -S -IC:\dev\gsoap-2.8\gsoap\import -x -w -n -qC2 ContestQsos2.h
// soapcpp2 -L -S env.h -penv
//

static const int MAX_CLIENT_BACKLOG = 20;

static bool keepRunning = true;

// static functions
static int http_get(struct soap *soap);

extern SOAP_NMAC struct Namespace C1_namespaces[];
extern SOAP_NMAC struct Namespace C2_namespaces[];

class CombinedNamespaces
{
    public:
        std::vector<struct Namespace> combinedNamespaces;

    public:
        void AddNamespaces(struct Namespace *pNamespace)
        {
            while (pNamespace->id != 0)
            {
                std::set<std::string>::iterator exists = ids.find(pNamespace->id);
                if (exists == ids.end())
                {
                    combinedNamespaces.push_back(*pNamespace);
                    ids.insert(pNamespace->id);
                }
                pNamespace++;
            }
        }
        void finish()
        {
            static struct Namespace end = {0,0,0,0};
            combinedNamespaces.push_back(end);
            ids.clear();
        }

    private:
        std::set<std::string> ids;
};

int main(int argc, char **argv)
{
    std::string userFile = "NONE";
    int portNumber = 8001;
    ContestQsos state;
    bool l6Flag = false;

    for (int i = 1; i < argc; i++)
    {
        std::string arg = argv[i];
        if (arg == "-h")
        {
            std::cout << std::endl
                << "usage: WritelogInetServer [-h] [-u <userFile>] [-p <portNumber>] [-v]" << std::endl << std::endl
                << "-v " << std::endl
                << "   turns on the verbose flag that prints sent/received QSO counts." << std::endl << std::endl
                << "-h " << std::endl
                << "   prints this help message" << std::endl << std::endl
                << "-u <userFile>" << std::endl
                << "   <userFile> is the path to a username/password file." << std::endl
                << "   The file is formatted with one username/password pair per line." << std::endl
                << "   Separate the username from the password with one space character." << std::endl
                << "   These become the legal entries from WriteLog users in their " << std::endl
                << "   Connect to Internet Logbook dialog." << std::endl << std::endl
                << "-p <portNumber>" << std::endl
                << "   This program requires a TCP port. The default without -p is 8001." << std::endl
                << "   The number must be in the range of 1 through 65534. Different operating" << std::endl
                << "   systems, internet providers, and routers will allow or not allow various" << std::endl
                << "   port numbers through." << std::endl
                << "-L6 " << std::endl
                << "   turns on the limit-labels-to-6-characters flag, which then rejects invalid input" << std::endl
                << "   from WriteLog versions earlier than 10.76." << std::endl
                << std::endl;
            return 1;
        }
        else if (arg == "-p")
        {
            if (++i >= argc)
            {
                std::cout << "-p must be followed by a port number." << std::endl;
                return 1;
            }
            portNumber = atoi(argv[i]);
            if (portNumber == 0)
            {
                std::cout << "portNumber " << argv[i] << " is not legal." << std::endl;
                return 1;
            }
        }
        else if (arg == "-u")
        {
            if (++i >= argc)
            {
                std::cout << "-u must be followed by a file name." << std::endl;
                return 1;
            }
            userFile = argv[i];
            if (!state.readUserFile(userFile))
            {
                std::cout << "Could not open " << userFile << std::endl;
                return 1;
            }
        }
        else if (arg == "-v")
        {
            state.setVerboseFlag(true);
        }
        else if (arg == "-L6")
        {
            state.setL6Flag(true);
            l6Flag = true;
        }
        else
        {
            std::cout << "Unrecognized argument: " << arg << std::endl;
            return 1;
        }
    }
    std::cout << "WritelogInetServer -h for help" << std::endl;
    std::cout << "Using port number " << portNumber << " and user file: " << userFile << std::endl;
    if (l6Flag)
        std::cout << "Limiting Network frequency labels to 6 characters for WriteLog version 10.75 and earlier." << std::endl;

    CombinedNamespaces combinedNamespaces;
    combinedNamespaces.AddNamespaces(C1_namespaces);
    combinedNamespaces.AddNamespaces(C2_namespaces);
    combinedNamespaces.finish();

    soap service;
    soap_init(&service);
    service.user = (void *)&state;
    service.accept_timeout =
        service.recv_timeout =
        service.send_timeout = 10;
    service.fget = &http_get; 
    service.namespaces = &combinedNamespaces.combinedNamespaces[0];
    int m; // master 
    m = soap_bind(&service, 0, portNumber, MAX_CLIENT_BACKLOG);
    if (m < 0)
        soap_print_fault(&service, stdout);
    else
    {
        for (int i = 1; ; i++)
        {
            if (!keepRunning)
                break;
            int s = soap_accept(&service);
            if (s < 0)  continue; // keep running until we get shutdown
            if (state.verbose())
            {
                std::cout << "Accepted connection from IP=" <<
                    (service.ip>>24 & 0xFF) << "." <<
                    (service.ip>>16 & 0xFF) << "." <<
                    (service.ip>>8 & 0xFF) << "." <<
                    (service.ip & 0xFF) << std::endl << std::flush;
            }
            if (soap_serve(&service) != SOAP_OK) // process RPC request
                soap_print_fault(&service, stdout); // print error
            if (state.verbose()) std::cout << "Request served" << std::endl << std::flush;
            soap_destroy(&service); // clean up class instances
            soap_end(&service);
        }
    }
    soap_done(&service); // close master socket and detach environment
    return 0;
}

// envServer.cpp must be compiled WITH_NOSERVEREQUEST
// so that THIS one is the only one at link time.
SOAP_FMAC5 int SOAP_FMAC6 soap_serve_request(struct soap *soap)
{
    // We are really two different soap servers. Try
    // one server and if it doesn't have the method,
    // try the other. C1 is WL v10, and C2 is WL v11
    int ret = C1::C1_serve_request(soap);
    if (ret == SOAP_NO_METHOD)
        return C2::C2_serve_request(soap);
    return ret;
}

// http_get***********************************************************************************************

// http_get is called by gSOAP on HTTP GET message
// We will return any file that happens to match, but filter out ".." from the URI
int http_get(struct soap *soap)
{
    if (!appState(soap)->useridAndPswdOK(soap->userid, soap->passwd))
        return 401; // not authorized

    std::string filePath = ".";
    filePath += soap->path;
    if (filePath.find("..") != filePath.npos) // .. chars not allowed
        return 404;

    FILE *fd = fopen(filePath.c_str(), "rb"); // open WSDL file to copy
    if (!fd) return 404; // return HTTP not found error

    if (filePath.find("SHUTDOWN") != filePath.npos)
    {
        std::cout << "User requested file " << filePath << 
            " and we are shutting down" << std::endl;
        keepRunning = false;	// show down the main server loop
    }

    soap->http_content = "text/xml"; // HTTP header with text/xml content
    soap_response(soap, SOAP_FILE);
    for (;;)
    {
        size_t r = fread(soap->tmpbuf, 1, sizeof(soap->tmpbuf), fd);
        if (!r)
            break;
        if (soap_send_raw(soap, soap->tmpbuf, r))
            break; // can't send, but little we can do about that
    }
    fclose(fd);
    soap_end_send(soap);
    return SOAP_OK;
} 