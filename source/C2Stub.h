/* C2Stub.h
   Generated by gSOAP 2.8.32 for ContestQsos2.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <deque>
#include <list>
#include <vector>
#include <set>
#define SOAP_NAMESPACE_OF_contest26	"http://schemas.microsoft.com/2003/10/Serialization/Arrays"
#define SOAP_NAMESPACE_OF_contest24	"http://schemas.microsoft.com/2003/10/Serialization/"
#define SOAP_NAMESPACE_OF_contest25	"http://schemas.datacontract.org/2004/07/ContestQsos"
#define SOAP_NAMESPACE_OF_contest23	"urn:ContestQsos2"
#define SOAP_NAMESPACE_OF_contest22	"urn:ContestQsos2/Imports"

#ifndef C2Stub_H
#define C2Stub_H
#ifndef WITH_NONAMESPACES
#define WITH_NONAMESPACES
#endif
#ifndef WITH_NOGLOBAL
#define WITH_NOGLOBAL
#endif
#include "stdsoap2.h"
#if GSOAP_VERSION != 20832
# error "GSOAP VERSION 20832 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


namespace C2 {

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/* ContestQsos2.h:165 */
#ifndef SOAP_TYPE_C2_xsd__QName
#define SOAP_TYPE_C2_xsd__QName (14)
typedef std::string xsd__QName;
#endif


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class xsd__anyType;	/* ContestQsos2.h:162 */
class xsd__base64Binary;	/* ContestQsos2.h:168 */
class xsd__ID_;	/* ContestQsos2.h:186 */
class xsd__IDREF_;	/* ContestQsos2.h:196 */
class xsd__QName_;	/* ContestQsos2.h:203 */
class xsd__anyURI_;	/* ContestQsos2.h:213 */
class xsd__base64Binary_;	/* ContestQsos2.h:220 */
class xsd__boolean;	/* ContestQsos2.h:227 */
class xsd__byte_;	/* ContestQsos2.h:234 */
class xsd__dateTime;	/* ContestQsos2.h:241 */
class xsd__decimal_;	/* ContestQsos2.h:251 */
class xsd__double;	/* ContestQsos2.h:258 */
class xsd__duration_;	/* ContestQsos2.h:268 */
class xsd__float;	/* ContestQsos2.h:275 */
class xsd__int;	/* ContestQsos2.h:282 */
class xsd__long;	/* ContestQsos2.h:289 */
class xsd__short;	/* ContestQsos2.h:296 */
class xsd__string;	/* ContestQsos2.h:303 */
class xsd__unsignedByte_;	/* ContestQsos2.h:310 */
class xsd__unsignedInt;	/* ContestQsos2.h:317 */
class xsd__unsignedLong;	/* ContestQsos2.h:324 */
class xsd__unsignedShort;	/* ContestQsos2.h:331 */
class contest24__char__;	/* ContestQsos2.h:456 */
class contest24__duration__;	/* ContestQsos2.h:469 */
class contest24__guid__;	/* ContestQsos2.h:481 */
class contest26__ArrayOfstring;	/* ContestQsos2.h:345 */
class contest26__ArrayOfint;	/* ContestQsos2.h:348 */
class contest25__ArrayOfQso;	/* ContestQsos2.h:351 */
class contest25__Qso;	/* ContestQsos2.h:354 */
class contest25__QsoUpdate;	/* ContestQsos2.h:357 */
class contest25__LogSummary;	/* ContestQsos2.h:360 */
class contest25__ArrayOfQsoIdVersion;	/* ContestQsos2.h:363 */
class contest25__QsoIdVersion;	/* ContestQsos2.h:366 */
class contest25__ArrayOfRigFrequency;	/* ContestQsos2.h:369 */
class contest25__RigFrequency;	/* ContestQsos2.h:372 */
class _contest23__GetSessionId;	/* ContestQsos2.h:375 */
class _contest23__GetSessionIdResponse;	/* ContestQsos2.h:378 */
class _contest23__addAndGetQsos;	/* ContestQsos2.h:381 */
class _contest23__addAndGetQsosResponse;	/* ContestQsos2.h:384 */
class _contest23__AddAndGetLogSummary;	/* ContestQsos2.h:387 */
class _contest23__AddAndGetLogSummaryResponse;	/* ContestQsos2.h:390 */
class _contest23__getQsosByKeyArray;	/* ContestQsos2.h:393 */
class _contest23__getQsosByKeyArrayResponse;	/* ContestQsos2.h:396 */
class _contest23__ColumnNamesToIndices;	/* ContestQsos2.h:399 */
class _contest23__ColumnNamesToIndicesResponse;	/* ContestQsos2.h:402 */
class _contest23__ExchangeFrequencies;	/* ContestQsos2.h:405 */
class _contest23__ExchangeFrequenciesResponse;	/* ContestQsos2.h:408 */
struct __contest23__GetSessionId;	/* ContestQsos2.h:1353 */
struct __contest23__addAndGetQsos;	/* ContestQsos2.h:1419 */
struct __contest23__AddAndGetLogSummary;	/* ContestQsos2.h:1485 */
struct __contest23__getQsosByKeyArray;	/* ContestQsos2.h:1551 */
struct __contest23__ColumnNamesToIndices;	/* ContestQsos2.h:1617 */
struct __contest23__ExchangeFrequencies;	/* ContestQsos2.h:1683 */

/* ContestQsos2.h:162 */
#ifndef SOAP_TYPE_C2_xsd__anyType
#define SOAP_TYPE_C2_xsd__anyType (11)
/* Type xsd__anyType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:anyType': */
class SOAP_CMAC xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:anyType' wrapped by this struct
        char *__item;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_C2_xsd__anyType
        virtual int soap_type(void) const { return SOAP_TYPE_C2_xsd__anyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__anyType, default initialized and not managed by a soap context
        virtual xsd__anyType *soap_alloc(void) const { return SOAP_NEW(xsd__anyType); }
      public:
        /// Constructor with initializations
        xsd__anyType()
        {
          __item = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~xsd__anyType() { }
        /// Friend allocator used by soap_new_xsd__anyType(struct soap*, int)
        friend SOAP_FMAC1 xsd__anyType * SOAP_FMAC2 soap_instantiate_xsd__anyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:168 */
#ifndef SOAP_TYPE_C2_xsd__base64Binary
#define SOAP_TYPE_C2_xsd__base64Binary (15)
/* binary data attached as MTOM/MIME/DIME attachment or included as *`xsd:base64Binary`* base64: */
class SOAP_CMAC xsd__base64Binary {
      public:
        unsigned char *__ptr;
        int __size;
        /// Optional element 'id' of XSD type 'xsd:string'
        char *id;
        /// Optional element 'type' of XSD type 'xsd:string'
        char *type;
        /// Optional element 'options' of XSD type 'xsd:string'
        char *options;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_C2_xsd__base64Binary
        virtual int soap_type(void) const { return SOAP_TYPE_C2_xsd__base64Binary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__base64Binary, default initialized and not managed by a soap context
        virtual xsd__base64Binary *soap_alloc(void) const { return SOAP_NEW(xsd__base64Binary); }
      public:
        /// Constructor with initializations
        xsd__base64Binary()
        {
          __ptr = (unsigned char *)0;
          __size = 0;
          id = NULL;
          type = (char *)0;
          options = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~xsd__base64Binary() { }
        /// Friend allocator used by soap_new_xsd__base64Binary(struct soap*, int)
        friend SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 soap_instantiate_xsd__base64Binary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:186 */
#ifndef SOAP_TYPE_C2_xsd__ID_
#define SOAP_TYPE_C2_xsd__ID_ (22)
/* Type xsd__ID_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:ID': */
class SOAP_CMAC xsd__ID_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:ID' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_C2_xsd__ID_
        virtual int soap_type(void) const { return SOAP_TYPE_C2_xsd__ID_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__ID_, default initialized and not managed by a soap context
        virtual xsd__ID_ *soap_alloc(void) const { return SOAP_NEW(xsd__ID_); }
      public:
        /// Constructor with initializations
        xsd__ID_()
        {
        }
        virtual ~xsd__ID_() { }
        /// Friend allocator used by soap_new_xsd__ID_(struct soap*, int)
        friend SOAP_FMAC1 xsd__ID_ * SOAP_FMAC2 soap_instantiate_xsd__ID_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:196 */
#ifndef SOAP_TYPE_C2_xsd__IDREF_
#define SOAP_TYPE_C2_xsd__IDREF_ (24)
/* Type xsd__IDREF_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:IDREF': */
class SOAP_CMAC xsd__IDREF_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:IDREF' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_C2_xsd__IDREF_
        virtual int soap_type(void) const { return SOAP_TYPE_C2_xsd__IDREF_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__IDREF_, default initialized and not managed by a soap context
        virtual xsd__IDREF_ *soap_alloc(void) const { return SOAP_NEW(xsd__IDREF_); }
      public:
        /// Constructor with initializations
        xsd__IDREF_()
        {
        }
        virtual ~xsd__IDREF_() { }
        /// Friend allocator used by soap_new_xsd__IDREF_(struct soap*, int)
        friend SOAP_FMAC1 xsd__IDREF_ * SOAP_FMAC2 soap_instantiate_xsd__IDREF_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:203 */
#ifndef SOAP_TYPE_C2_xsd__QName_
#define SOAP_TYPE_C2_xsd__QName_ (25)
/* Type xsd__QName_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:QName': */
class SOAP_CMAC xsd__QName_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:QName' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_C2_xsd__QName_
        virtual int soap_type(void) const { return SOAP_TYPE_C2_xsd__QName_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__QName_, default initialized and not managed by a soap context
        virtual xsd__QName_ *soap_alloc(void) const { return SOAP_NEW(xsd__QName_); }
      public:
        /// Constructor with initializations
        xsd__QName_()
        {
        }
        virtual ~xsd__QName_() { }
        /// Friend allocator used by soap_new_xsd__QName_(struct soap*, int)
        friend SOAP_FMAC1 xsd__QName_ * SOAP_FMAC2 soap_instantiate_xsd__QName_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:213 */
#ifndef SOAP_TYPE_C2_xsd__anyURI_
#define SOAP_TYPE_C2_xsd__anyURI_ (27)
/* Type xsd__anyURI_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:anyURI': */
class SOAP_CMAC xsd__anyURI_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:anyURI' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_C2_xsd__anyURI_
        virtual int soap_type(void) const { return SOAP_TYPE_C2_xsd__anyURI_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__anyURI_, default initialized and not managed by a soap context
        virtual xsd__anyURI_ *soap_alloc(void) const { return SOAP_NEW(xsd__anyURI_); }
      public:
        /// Constructor with initializations
        xsd__anyURI_()
        {
        }
        virtual ~xsd__anyURI_() { }
        /// Friend allocator used by soap_new_xsd__anyURI_(struct soap*, int)
        friend SOAP_FMAC1 xsd__anyURI_ * SOAP_FMAC2 soap_instantiate_xsd__anyURI_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:220 */
#ifndef SOAP_TYPE_C2_xsd__base64Binary_
#define SOAP_TYPE_C2_xsd__base64Binary_ (28)
/* Type xsd__base64Binary_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:base64Binary': */
class SOAP_CMAC xsd__base64Binary_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:base64Binary' wrapped by this struct
        xsd__base64Binary __item;
      public:
        /// Return unique type id SOAP_TYPE_C2_xsd__base64Binary_
        virtual int soap_type(void) const { return SOAP_TYPE_C2_xsd__base64Binary_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__base64Binary_, default initialized and not managed by a soap context
        virtual xsd__base64Binary_ *soap_alloc(void) const { return SOAP_NEW(xsd__base64Binary_); }
      public:
        /// Constructor with initializations
        xsd__base64Binary_()
        {
        }
        virtual ~xsd__base64Binary_() { }
        /// Friend allocator used by soap_new_xsd__base64Binary_(struct soap*, int)
        friend SOAP_FMAC1 xsd__base64Binary_ * SOAP_FMAC2 soap_instantiate_xsd__base64Binary_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:227 */
#ifndef SOAP_TYPE_C2_xsd__boolean
#define SOAP_TYPE_C2_xsd__boolean (29)
/* Type xsd__boolean is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:boolean': */
class SOAP_CMAC xsd__boolean : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:boolean' wrapped by this struct
        bool __item;
      public:
        /// Return unique type id SOAP_TYPE_C2_xsd__boolean
        virtual int soap_type(void) const { return SOAP_TYPE_C2_xsd__boolean; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__boolean, default initialized and not managed by a soap context
        virtual xsd__boolean *soap_alloc(void) const { return SOAP_NEW(xsd__boolean); }
      public:
        /// Constructor with initializations
        xsd__boolean()
        {
          __item = (bool)0;
        }
        virtual ~xsd__boolean() { }
        /// Friend allocator used by soap_new_xsd__boolean(struct soap*, int)
        friend SOAP_FMAC1 xsd__boolean * SOAP_FMAC2 soap_instantiate_xsd__boolean(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:234 */
#ifndef SOAP_TYPE_C2_xsd__byte_
#define SOAP_TYPE_C2_xsd__byte_ (31)
/* Type xsd__byte_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:byte': */
class SOAP_CMAC xsd__byte_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:byte' wrapped by this struct
        char __item;
      public:
        /// Return unique type id SOAP_TYPE_C2_xsd__byte_
        virtual int soap_type(void) const { return SOAP_TYPE_C2_xsd__byte_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__byte_, default initialized and not managed by a soap context
        virtual xsd__byte_ *soap_alloc(void) const { return SOAP_NEW(xsd__byte_); }
      public:
        /// Constructor with initializations
        xsd__byte_()
        {
          __item = (char)0;
        }
        virtual ~xsd__byte_() { }
        /// Friend allocator used by soap_new_xsd__byte_(struct soap*, int)
        friend SOAP_FMAC1 xsd__byte_ * SOAP_FMAC2 soap_instantiate_xsd__byte_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:241 */
#ifndef SOAP_TYPE_C2_xsd__dateTime
#define SOAP_TYPE_C2_xsd__dateTime (32)
/* Type xsd__dateTime is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:dateTime': */
class SOAP_CMAC xsd__dateTime : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:dateTime' wrapped by this struct
        time_t __item;
      public:
        /// Return unique type id SOAP_TYPE_C2_xsd__dateTime
        virtual int soap_type(void) const { return SOAP_TYPE_C2_xsd__dateTime; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__dateTime, default initialized and not managed by a soap context
        virtual xsd__dateTime *soap_alloc(void) const { return SOAP_NEW(xsd__dateTime); }
      public:
        /// Constructor with initializations
        xsd__dateTime()
        {
          __item = (time_t)0;
        }
        virtual ~xsd__dateTime() { }
        /// Friend allocator used by soap_new_xsd__dateTime(struct soap*, int)
        friend SOAP_FMAC1 xsd__dateTime * SOAP_FMAC2 soap_instantiate_xsd__dateTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:251 */
#ifndef SOAP_TYPE_C2_xsd__decimal_
#define SOAP_TYPE_C2_xsd__decimal_ (35)
/* Type xsd__decimal_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:decimal': */
class SOAP_CMAC xsd__decimal_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:decimal' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_C2_xsd__decimal_
        virtual int soap_type(void) const { return SOAP_TYPE_C2_xsd__decimal_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__decimal_, default initialized and not managed by a soap context
        virtual xsd__decimal_ *soap_alloc(void) const { return SOAP_NEW(xsd__decimal_); }
      public:
        /// Constructor with initializations
        xsd__decimal_()
        {
        }
        virtual ~xsd__decimal_() { }
        /// Friend allocator used by soap_new_xsd__decimal_(struct soap*, int)
        friend SOAP_FMAC1 xsd__decimal_ * SOAP_FMAC2 soap_instantiate_xsd__decimal_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:258 */
#ifndef SOAP_TYPE_C2_xsd__double
#define SOAP_TYPE_C2_xsd__double (36)
/* Type xsd__double is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:double': */
class SOAP_CMAC xsd__double : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:double' wrapped by this struct
        double __item;
      public:
        /// Return unique type id SOAP_TYPE_C2_xsd__double
        virtual int soap_type(void) const { return SOAP_TYPE_C2_xsd__double; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__double, default initialized and not managed by a soap context
        virtual xsd__double *soap_alloc(void) const { return SOAP_NEW(xsd__double); }
      public:
        /// Constructor with initializations
        xsd__double()
        {
          __item = (double)0;
        }
        virtual ~xsd__double() { }
        /// Friend allocator used by soap_new_xsd__double(struct soap*, int)
        friend SOAP_FMAC1 xsd__double * SOAP_FMAC2 soap_instantiate_xsd__double(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:268 */
#ifndef SOAP_TYPE_C2_xsd__duration_
#define SOAP_TYPE_C2_xsd__duration_ (39)
/* Type xsd__duration_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:duration': */
class SOAP_CMAC xsd__duration_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:duration' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_C2_xsd__duration_
        virtual int soap_type(void) const { return SOAP_TYPE_C2_xsd__duration_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__duration_, default initialized and not managed by a soap context
        virtual xsd__duration_ *soap_alloc(void) const { return SOAP_NEW(xsd__duration_); }
      public:
        /// Constructor with initializations
        xsd__duration_()
        {
        }
        virtual ~xsd__duration_() { }
        /// Friend allocator used by soap_new_xsd__duration_(struct soap*, int)
        friend SOAP_FMAC1 xsd__duration_ * SOAP_FMAC2 soap_instantiate_xsd__duration_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:275 */
#ifndef SOAP_TYPE_C2_xsd__float
#define SOAP_TYPE_C2_xsd__float (40)
/* Type xsd__float is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:float': */
class SOAP_CMAC xsd__float : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:float' wrapped by this struct
        float __item;
      public:
        /// Return unique type id SOAP_TYPE_C2_xsd__float
        virtual int soap_type(void) const { return SOAP_TYPE_C2_xsd__float; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__float, default initialized and not managed by a soap context
        virtual xsd__float *soap_alloc(void) const { return SOAP_NEW(xsd__float); }
      public:
        /// Constructor with initializations
        xsd__float()
        {
          __item = (float)0;
        }
        virtual ~xsd__float() { }
        /// Friend allocator used by soap_new_xsd__float(struct soap*, int)
        friend SOAP_FMAC1 xsd__float * SOAP_FMAC2 soap_instantiate_xsd__float(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:282 */
#ifndef SOAP_TYPE_C2_xsd__int
#define SOAP_TYPE_C2_xsd__int (42)
/* Type xsd__int is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:int': */
class SOAP_CMAC xsd__int : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:int' wrapped by this struct
        int __item;
      public:
        /// Return unique type id SOAP_TYPE_C2_xsd__int
        virtual int soap_type(void) const { return SOAP_TYPE_C2_xsd__int; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__int, default initialized and not managed by a soap context
        virtual xsd__int *soap_alloc(void) const { return SOAP_NEW(xsd__int); }
      public:
        /// Constructor with initializations
        xsd__int()
        {
          __item = (int)0;
        }
        virtual ~xsd__int() { }
        /// Friend allocator used by soap_new_xsd__int(struct soap*, int)
        friend SOAP_FMAC1 xsd__int * SOAP_FMAC2 soap_instantiate_xsd__int(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:289 */
#ifndef SOAP_TYPE_C2_xsd__long
#define SOAP_TYPE_C2_xsd__long (43)
/* Type xsd__long is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:long': */
class SOAP_CMAC xsd__long : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:long' wrapped by this struct
        LONG64 __item;
      public:
        /// Return unique type id SOAP_TYPE_C2_xsd__long
        virtual int soap_type(void) const { return SOAP_TYPE_C2_xsd__long; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__long, default initialized and not managed by a soap context
        virtual xsd__long *soap_alloc(void) const { return SOAP_NEW(xsd__long); }
      public:
        /// Constructor with initializations
        xsd__long()
        {
          __item = (LONG64)0;
        }
        virtual ~xsd__long() { }
        /// Friend allocator used by soap_new_xsd__long(struct soap*, int)
        friend SOAP_FMAC1 xsd__long * SOAP_FMAC2 soap_instantiate_xsd__long(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:296 */
#ifndef SOAP_TYPE_C2_xsd__short
#define SOAP_TYPE_C2_xsd__short (45)
/* Type xsd__short is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:short': */
class SOAP_CMAC xsd__short : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:short' wrapped by this struct
        short __item;
      public:
        /// Return unique type id SOAP_TYPE_C2_xsd__short
        virtual int soap_type(void) const { return SOAP_TYPE_C2_xsd__short; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__short, default initialized and not managed by a soap context
        virtual xsd__short *soap_alloc(void) const { return SOAP_NEW(xsd__short); }
      public:
        /// Constructor with initializations
        xsd__short()
        {
          __item = (short)0;
        }
        virtual ~xsd__short() { }
        /// Friend allocator used by soap_new_xsd__short(struct soap*, int)
        friend SOAP_FMAC1 xsd__short * SOAP_FMAC2 soap_instantiate_xsd__short(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:303 */
#ifndef SOAP_TYPE_C2_xsd__string
#define SOAP_TYPE_C2_xsd__string (47)
/* Type xsd__string is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:string': */
class SOAP_CMAC xsd__string : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:string' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_C2_xsd__string
        virtual int soap_type(void) const { return SOAP_TYPE_C2_xsd__string; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__string, default initialized and not managed by a soap context
        virtual xsd__string *soap_alloc(void) const { return SOAP_NEW(xsd__string); }
      public:
        /// Constructor with initializations
        xsd__string()
        {
        }
        virtual ~xsd__string() { }
        /// Friend allocator used by soap_new_xsd__string(struct soap*, int)
        friend SOAP_FMAC1 xsd__string * SOAP_FMAC2 soap_instantiate_xsd__string(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:310 */
#ifndef SOAP_TYPE_C2_xsd__unsignedByte_
#define SOAP_TYPE_C2_xsd__unsignedByte_ (48)
/* Type xsd__unsignedByte_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:unsignedByte': */
class SOAP_CMAC xsd__unsignedByte_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:unsignedByte' wrapped by this struct
        unsigned char __item;
      public:
        /// Return unique type id SOAP_TYPE_C2_xsd__unsignedByte_
        virtual int soap_type(void) const { return SOAP_TYPE_C2_xsd__unsignedByte_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__unsignedByte_, default initialized and not managed by a soap context
        virtual xsd__unsignedByte_ *soap_alloc(void) const { return SOAP_NEW(xsd__unsignedByte_); }
      public:
        /// Constructor with initializations
        xsd__unsignedByte_()
        {
          __item = (unsigned char)0;
        }
        virtual ~xsd__unsignedByte_() { }
        /// Friend allocator used by soap_new_xsd__unsignedByte_(struct soap*, int)
        friend SOAP_FMAC1 xsd__unsignedByte_ * SOAP_FMAC2 soap_instantiate_xsd__unsignedByte_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:317 */
#ifndef SOAP_TYPE_C2_xsd__unsignedInt
#define SOAP_TYPE_C2_xsd__unsignedInt (49)
/* Type xsd__unsignedInt is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:unsignedInt': */
class SOAP_CMAC xsd__unsignedInt : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:unsignedInt' wrapped by this struct
        unsigned int __item;
      public:
        /// Return unique type id SOAP_TYPE_C2_xsd__unsignedInt
        virtual int soap_type(void) const { return SOAP_TYPE_C2_xsd__unsignedInt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__unsignedInt, default initialized and not managed by a soap context
        virtual xsd__unsignedInt *soap_alloc(void) const { return SOAP_NEW(xsd__unsignedInt); }
      public:
        /// Constructor with initializations
        xsd__unsignedInt()
        {
          __item = (unsigned int)0;
        }
        virtual ~xsd__unsignedInt() { }
        /// Friend allocator used by soap_new_xsd__unsignedInt(struct soap*, int)
        friend SOAP_FMAC1 xsd__unsignedInt * SOAP_FMAC2 soap_instantiate_xsd__unsignedInt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:324 */
#ifndef SOAP_TYPE_C2_xsd__unsignedLong
#define SOAP_TYPE_C2_xsd__unsignedLong (50)
/* Type xsd__unsignedLong is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:unsignedLong': */
class SOAP_CMAC xsd__unsignedLong : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:unsignedLong' wrapped by this struct
        ULONG64 __item;
      public:
        /// Return unique type id SOAP_TYPE_C2_xsd__unsignedLong
        virtual int soap_type(void) const { return SOAP_TYPE_C2_xsd__unsignedLong; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__unsignedLong, default initialized and not managed by a soap context
        virtual xsd__unsignedLong *soap_alloc(void) const { return SOAP_NEW(xsd__unsignedLong); }
      public:
        /// Constructor with initializations
        xsd__unsignedLong()
        {
          __item = (ULONG64)0;
        }
        virtual ~xsd__unsignedLong() { }
        /// Friend allocator used by soap_new_xsd__unsignedLong(struct soap*, int)
        friend SOAP_FMAC1 xsd__unsignedLong * SOAP_FMAC2 soap_instantiate_xsd__unsignedLong(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:331 */
#ifndef SOAP_TYPE_C2_xsd__unsignedShort
#define SOAP_TYPE_C2_xsd__unsignedShort (52)
/* Type xsd__unsignedShort is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:unsignedShort': */
class SOAP_CMAC xsd__unsignedShort : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:unsignedShort' wrapped by this struct
        unsigned short __item;
      public:
        /// Return unique type id SOAP_TYPE_C2_xsd__unsignedShort
        virtual int soap_type(void) const { return SOAP_TYPE_C2_xsd__unsignedShort; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__unsignedShort, default initialized and not managed by a soap context
        virtual xsd__unsignedShort *soap_alloc(void) const { return SOAP_NEW(xsd__unsignedShort); }
      public:
        /// Constructor with initializations
        xsd__unsignedShort()
        {
          __item = (unsigned short)0;
        }
        virtual ~xsd__unsignedShort() { }
        /// Friend allocator used by soap_new_xsd__unsignedShort(struct soap*, int)
        friend SOAP_FMAC1 xsd__unsignedShort * SOAP_FMAC2 soap_instantiate_xsd__unsignedShort(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:456 */
#ifndef SOAP_TYPE_C2_contest24__char__
#define SOAP_TYPE_C2_contest24__char__ (77)
/* Type contest24__char__ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'contest24:char': */
class SOAP_CMAC contest24__char__ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'contest24:char' wrapped by this struct
        int __item;
      public:
        /// Return unique type id SOAP_TYPE_C2_contest24__char__
        virtual int soap_type(void) const { return SOAP_TYPE_C2_contest24__char__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type contest24__char__, default initialized and not managed by a soap context
        virtual contest24__char__ *soap_alloc(void) const { return SOAP_NEW(contest24__char__); }
      public:
        /// Constructor with initializations
        contest24__char__()
        {
          __item = (int)0;
        }
        virtual ~contest24__char__() { }
        /// Friend allocator used by soap_new_contest24__char__(struct soap*, int)
        friend SOAP_FMAC1 contest24__char__ * SOAP_FMAC2 soap_instantiate_contest24__char__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:469 */
#ifndef SOAP_TYPE_C2_contest24__duration__
#define SOAP_TYPE_C2_contest24__duration__ (79)
/* Type contest24__duration__ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'contest24:duration': */
class SOAP_CMAC contest24__duration__ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'contest24:duration' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_C2_contest24__duration__
        virtual int soap_type(void) const { return SOAP_TYPE_C2_contest24__duration__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type contest24__duration__, default initialized and not managed by a soap context
        virtual contest24__duration__ *soap_alloc(void) const { return SOAP_NEW(contest24__duration__); }
      public:
        /// Constructor with initializations
        contest24__duration__()
        {
        }
        virtual ~contest24__duration__() { }
        /// Friend allocator used by soap_new_contest24__duration__(struct soap*, int)
        friend SOAP_FMAC1 contest24__duration__ * SOAP_FMAC2 soap_instantiate_contest24__duration__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:481 */
#ifndef SOAP_TYPE_C2_contest24__guid__
#define SOAP_TYPE_C2_contest24__guid__ (81)
/* Type contest24__guid__ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'contest24:guid': */
class SOAP_CMAC contest24__guid__ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'contest24:guid' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_C2_contest24__guid__
        virtual int soap_type(void) const { return SOAP_TYPE_C2_contest24__guid__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type contest24__guid__, default initialized and not managed by a soap context
        virtual contest24__guid__ *soap_alloc(void) const { return SOAP_NEW(contest24__guid__); }
      public:
        /// Constructor with initializations
        contest24__guid__()
        {
        }
        virtual ~contest24__guid__() { }
        /// Friend allocator used by soap_new_contest24__guid__(struct soap*, int)
        friend SOAP_FMAC1 contest24__guid__ * SOAP_FMAC2 soap_instantiate_contest24__guid__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:345 */
#ifndef SOAP_TYPE_C2_contest26__ArrayOfstring
#define SOAP_TYPE_C2_contest26__ArrayOfstring (54)
/* Type contest26__ArrayOfstring is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'contest26:ArrayOfstring': */
class SOAP_CMAC contest26__ArrayOfstring : public xsd__anyType {
      public:
        /// Optional element 'contest26:string' of XSD type 'xsd:string'
        std::vector<std::string> string;
      public:
        /// Return unique type id SOAP_TYPE_C2_contest26__ArrayOfstring
        virtual int soap_type(void) const { return SOAP_TYPE_C2_contest26__ArrayOfstring; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type contest26__ArrayOfstring, default initialized and not managed by a soap context
        virtual contest26__ArrayOfstring *soap_alloc(void) const { return SOAP_NEW(contest26__ArrayOfstring); }
      public:
        /// Constructor with initializations
        contest26__ArrayOfstring()
        {
        }
        virtual ~contest26__ArrayOfstring() { }
        /// Friend allocator used by soap_new_contest26__ArrayOfstring(struct soap*, int)
        friend SOAP_FMAC1 contest26__ArrayOfstring * SOAP_FMAC2 soap_instantiate_contest26__ArrayOfstring(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:348 */
#ifndef SOAP_TYPE_C2_contest26__ArrayOfint
#define SOAP_TYPE_C2_contest26__ArrayOfint (55)
/* Type contest26__ArrayOfint is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'contest26:ArrayOfint': */
class SOAP_CMAC contest26__ArrayOfint : public xsd__anyType {
      public:
        /// Optional element 'contest26:int' of XSD type 'xsd:int'
        std::vector<int> int_;
      public:
        /// Return unique type id SOAP_TYPE_C2_contest26__ArrayOfint
        virtual int soap_type(void) const { return SOAP_TYPE_C2_contest26__ArrayOfint; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type contest26__ArrayOfint, default initialized and not managed by a soap context
        virtual contest26__ArrayOfint *soap_alloc(void) const { return SOAP_NEW(contest26__ArrayOfint); }
      public:
        /// Constructor with initializations
        contest26__ArrayOfint()
        {
        }
        virtual ~contest26__ArrayOfint() { }
        /// Friend allocator used by soap_new_contest26__ArrayOfint(struct soap*, int)
        friend SOAP_FMAC1 contest26__ArrayOfint * SOAP_FMAC2 soap_instantiate_contest26__ArrayOfint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:351 */
#ifndef SOAP_TYPE_C2_contest25__ArrayOfQso
#define SOAP_TYPE_C2_contest25__ArrayOfQso (56)
/* Type contest25__ArrayOfQso is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'contest25:ArrayOfQso': */
class SOAP_CMAC contest25__ArrayOfQso : public xsd__anyType {
      public:
        /// Optional element 'contest25:Qso' of XSD type 'contest25:Qso'
        std::vector<contest25__Qso *> Qso;
      public:
        /// Return unique type id SOAP_TYPE_C2_contest25__ArrayOfQso
        virtual int soap_type(void) const { return SOAP_TYPE_C2_contest25__ArrayOfQso; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type contest25__ArrayOfQso, default initialized and not managed by a soap context
        virtual contest25__ArrayOfQso *soap_alloc(void) const { return SOAP_NEW(contest25__ArrayOfQso); }
      public:
        /// Constructor with initializations
        contest25__ArrayOfQso()
        {
        }
        virtual ~contest25__ArrayOfQso() { }
        /// Friend allocator used by soap_new_contest25__ArrayOfQso(struct soap*, int)
        friend SOAP_FMAC1 contest25__ArrayOfQso * SOAP_FMAC2 soap_instantiate_contest25__ArrayOfQso(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:354 */
#ifndef SOAP_TYPE_C2_contest25__Qso
#define SOAP_TYPE_C2_contest25__Qso (57)
/* Type contest25__Qso is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'contest25:Qso': */
class SOAP_CMAC contest25__Qso : public xsd__anyType {
      public:
        /// Required element 'contest25:band' of XSD type 'xsd:int'
        int band;
        /// Required element 'contest25:dupe' of XSD type 'xsd:int'
        int dupe;
        /// Required element 'contest25:idKey' of XSD type 'xsd:string'
        std::string idKey;
        /// Required element 'contest25:mode' of XSD type 'xsd:int'
        int mode;
        /// Required element 'contest25:qsoparts' of XSD type 'contest26:ArrayOfstring'
        contest26__ArrayOfstring *qsoparts;
        /// Required element 'contest25:recvFreq' of XSD type 'xsd:double'
        double recvFreq;
        /// Required element 'contest25:serial' of XSD type 'xsd:int'
        int serial;
        /// Required element 'contest25:station' of XSD type 'xsd:string'
        std::string station;
        /// Required element 'contest25:time64H' of XSD type 'xsd:int'
        int time64H;
        /// Required element 'contest25:time64L' of XSD type 'xsd:int'
        int time64L;
        /// Required element 'contest25:updatedBy' of XSD type 'xsd:string'
        std::string updatedBy;
        /// Required element 'contest25:version' of XSD type 'xsd:int'
        int version;
        /// Required element 'contest25:xmitFreq' of XSD type 'xsd:double'
        double xmitFreq;
      public:
        /// Return unique type id SOAP_TYPE_C2_contest25__Qso
        virtual int soap_type(void) const { return SOAP_TYPE_C2_contest25__Qso; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type contest25__Qso, default initialized and not managed by a soap context
        virtual contest25__Qso *soap_alloc(void) const { return SOAP_NEW(contest25__Qso); }
      public:
        /// Constructor with initializations
        contest25__Qso()
        {
          band = (int)0;
          dupe = (int)0;
          mode = (int)0;
          qsoparts = (contest26__ArrayOfstring *)0;
          recvFreq = (double)0;
          serial = (int)0;
          time64H = (int)0;
          time64L = (int)0;
          version = (int)0;
          xmitFreq = (double)0;
        }
        virtual ~contest25__Qso() { }
        /// Friend allocator used by soap_new_contest25__Qso(struct soap*, int)
        friend SOAP_FMAC1 contest25__Qso * SOAP_FMAC2 soap_instantiate_contest25__Qso(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:357 */
#ifndef SOAP_TYPE_C2_contest25__QsoUpdate
#define SOAP_TYPE_C2_contest25__QsoUpdate (58)
/* Type contest25__QsoUpdate is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'contest25:QsoUpdate': */
class SOAP_CMAC contest25__QsoUpdate : public xsd__anyType {
      public:
        /// Required element 'contest25:logState' of XSD type 'xsd:int'
        int logState;
        /// Required element 'contest25:qsoArray' of XSD type 'contest25:ArrayOfQso'
        contest25__ArrayOfQso *qsoArray;
      public:
        /// Return unique type id SOAP_TYPE_C2_contest25__QsoUpdate
        virtual int soap_type(void) const { return SOAP_TYPE_C2_contest25__QsoUpdate; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type contest25__QsoUpdate, default initialized and not managed by a soap context
        virtual contest25__QsoUpdate *soap_alloc(void) const { return SOAP_NEW(contest25__QsoUpdate); }
      public:
        /// Constructor with initializations
        contest25__QsoUpdate()
        {
          logState = (int)0;
          qsoArray = (contest25__ArrayOfQso *)0;
        }
        virtual ~contest25__QsoUpdate() { }
        /// Friend allocator used by soap_new_contest25__QsoUpdate(struct soap*, int)
        friend SOAP_FMAC1 contest25__QsoUpdate * SOAP_FMAC2 soap_instantiate_contest25__QsoUpdate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:360 */
#ifndef SOAP_TYPE_C2_contest25__LogSummary
#define SOAP_TYPE_C2_contest25__LogSummary (59)
/* Type contest25__LogSummary is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'contest25:LogSummary': */
class SOAP_CMAC contest25__LogSummary : public xsd__anyType {
      public:
        /// Required element 'contest25:logState' of XSD type 'xsd:int'
        int logState;
        /// Required element 'contest25:logSummaryIds' of XSD type 'contest25:ArrayOfQsoIdVersion'
        contest25__ArrayOfQsoIdVersion *logSummaryIds;
      public:
        /// Return unique type id SOAP_TYPE_C2_contest25__LogSummary
        virtual int soap_type(void) const { return SOAP_TYPE_C2_contest25__LogSummary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type contest25__LogSummary, default initialized and not managed by a soap context
        virtual contest25__LogSummary *soap_alloc(void) const { return SOAP_NEW(contest25__LogSummary); }
      public:
        /// Constructor with initializations
        contest25__LogSummary()
        {
          logState = (int)0;
          logSummaryIds = (contest25__ArrayOfQsoIdVersion *)0;
        }
        virtual ~contest25__LogSummary() { }
        /// Friend allocator used by soap_new_contest25__LogSummary(struct soap*, int)
        friend SOAP_FMAC1 contest25__LogSummary * SOAP_FMAC2 soap_instantiate_contest25__LogSummary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:363 */
#ifndef SOAP_TYPE_C2_contest25__ArrayOfQsoIdVersion
#define SOAP_TYPE_C2_contest25__ArrayOfQsoIdVersion (60)
/* Type contest25__ArrayOfQsoIdVersion is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'contest25:ArrayOfQsoIdVersion': */
class SOAP_CMAC contest25__ArrayOfQsoIdVersion : public xsd__anyType {
      public:
        /// Optional element 'contest25:QsoIdVersion' of XSD type 'contest25:QsoIdVersion'
        std::vector<contest25__QsoIdVersion *> QsoIdVersion;
      public:
        /// Return unique type id SOAP_TYPE_C2_contest25__ArrayOfQsoIdVersion
        virtual int soap_type(void) const { return SOAP_TYPE_C2_contest25__ArrayOfQsoIdVersion; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type contest25__ArrayOfQsoIdVersion, default initialized and not managed by a soap context
        virtual contest25__ArrayOfQsoIdVersion *soap_alloc(void) const { return SOAP_NEW(contest25__ArrayOfQsoIdVersion); }
      public:
        /// Constructor with initializations
        contest25__ArrayOfQsoIdVersion()
        {
        }
        virtual ~contest25__ArrayOfQsoIdVersion() { }
        /// Friend allocator used by soap_new_contest25__ArrayOfQsoIdVersion(struct soap*, int)
        friend SOAP_FMAC1 contest25__ArrayOfQsoIdVersion * SOAP_FMAC2 soap_instantiate_contest25__ArrayOfQsoIdVersion(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:366 */
#ifndef SOAP_TYPE_C2_contest25__QsoIdVersion
#define SOAP_TYPE_C2_contest25__QsoIdVersion (61)
/* Type contest25__QsoIdVersion is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'contest25:QsoIdVersion': */
class SOAP_CMAC contest25__QsoIdVersion : public xsd__anyType {
      public:
        /// Required element 'contest25:id' of XSD type 'xsd:string'
        std::string id;
        /// Required element 'contest25:updatedBy' of XSD type 'xsd:string'
        std::string updatedBy;
        /// Required element 'contest25:version' of XSD type 'xsd:int'
        int version;
      public:
        /// Return unique type id SOAP_TYPE_C2_contest25__QsoIdVersion
        virtual int soap_type(void) const { return SOAP_TYPE_C2_contest25__QsoIdVersion; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type contest25__QsoIdVersion, default initialized and not managed by a soap context
        virtual contest25__QsoIdVersion *soap_alloc(void) const { return SOAP_NEW(contest25__QsoIdVersion); }
      public:
        /// Constructor with initializations
        contest25__QsoIdVersion()
        {
          version = (int)0;
        }
        virtual ~contest25__QsoIdVersion() { }
        /// Friend allocator used by soap_new_contest25__QsoIdVersion(struct soap*, int)
        friend SOAP_FMAC1 contest25__QsoIdVersion * SOAP_FMAC2 soap_instantiate_contest25__QsoIdVersion(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:369 */
#ifndef SOAP_TYPE_C2_contest25__ArrayOfRigFrequency
#define SOAP_TYPE_C2_contest25__ArrayOfRigFrequency (62)
/* Type contest25__ArrayOfRigFrequency is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'contest25:ArrayOfRigFrequency': */
class SOAP_CMAC contest25__ArrayOfRigFrequency : public xsd__anyType {
      public:
        /// Required element 'contest25:RigFrequency' of XSD type 'contest25:RigFrequency'
        std::vector<contest25__RigFrequency *> RigFrequency;
      public:
        /// Return unique type id SOAP_TYPE_C2_contest25__ArrayOfRigFrequency
        virtual int soap_type(void) const { return SOAP_TYPE_C2_contest25__ArrayOfRigFrequency; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type contest25__ArrayOfRigFrequency, default initialized and not managed by a soap context
        virtual contest25__ArrayOfRigFrequency *soap_alloc(void) const { return SOAP_NEW(contest25__ArrayOfRigFrequency); }
      public:
        /// Constructor with initializations
        contest25__ArrayOfRigFrequency()
        {
        }
        virtual ~contest25__ArrayOfRigFrequency() { }
        /// Friend allocator used by soap_new_contest25__ArrayOfRigFrequency(struct soap*, int)
        friend SOAP_FMAC1 contest25__ArrayOfRigFrequency * SOAP_FMAC2 soap_instantiate_contest25__ArrayOfRigFrequency(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:372 */
#ifndef SOAP_TYPE_C2_contest25__RigFrequency
#define SOAP_TYPE_C2_contest25__RigFrequency (63)
/* Type contest25__RigFrequency is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'contest25:RigFrequency': */
class SOAP_CMAC contest25__RigFrequency : public xsd__anyType {
      public:
        /// Required element 'contest25:label' of XSD type 'xsd:string'
        std::string label;
        /// Required element 'contest25:mode' of XSD type 'xsd:int'
        int mode;
        /// Required element 'contest25:networkLetter' of XSD type 'xsd:int'
        int networkLetter;
        /// Required element 'contest25:recvFreq' of XSD type 'xsd:double'
        double recvFreq;
        /// Required element 'contest25:rigNumber' of XSD type 'xsd:int'
        int rigNumber;
        /// Required element 'contest25:station' of XSD type 'xsd:string'
        std::string station;
        /// Required element 'contest25:xmitFreq' of XSD type 'xsd:double'
        double xmitFreq;
      public:
        /// Return unique type id SOAP_TYPE_C2_contest25__RigFrequency
        virtual int soap_type(void) const { return SOAP_TYPE_C2_contest25__RigFrequency; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type contest25__RigFrequency, default initialized and not managed by a soap context
        virtual contest25__RigFrequency *soap_alloc(void) const { return SOAP_NEW(contest25__RigFrequency); }
      public:
        /// Constructor with initializations
        contest25__RigFrequency()
        {
          mode = (int)0;
          networkLetter = (int)0;
          recvFreq = (double)0;
          rigNumber = (int)0;
          xmitFreq = (double)0;
        }
        virtual ~contest25__RigFrequency() { }
        /// Friend allocator used by soap_new_contest25__RigFrequency(struct soap*, int)
        friend SOAP_FMAC1 contest25__RigFrequency * SOAP_FMAC2 soap_instantiate_contest25__RigFrequency(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:375 */
#ifndef SOAP_TYPE_C2__contest23__GetSessionId
#define SOAP_TYPE_C2__contest23__GetSessionId (64)
/* complex XSD type 'contest23:GetSessionId': */
class SOAP_CMAC _contest23__GetSessionId {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_C2__contest23__GetSessionId
        virtual int soap_type(void) const { return SOAP_TYPE_C2__contest23__GetSessionId; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _contest23__GetSessionId, default initialized and not managed by a soap context
        virtual _contest23__GetSessionId *soap_alloc(void) const { return SOAP_NEW(_contest23__GetSessionId); }
      public:
        /// Constructor with initializations
        _contest23__GetSessionId()
        {
          soap = (struct soap *)0;
        }
        virtual ~_contest23__GetSessionId() { }
        /// Friend allocator used by soap_new__contest23__GetSessionId(struct soap*, int)
        friend SOAP_FMAC1 _contest23__GetSessionId * SOAP_FMAC2 soap_instantiate__contest23__GetSessionId(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:378 */
#ifndef SOAP_TYPE_C2__contest23__GetSessionIdResponse
#define SOAP_TYPE_C2__contest23__GetSessionIdResponse (65)
/* complex XSD type 'contest23:GetSessionIdResponse': */
class SOAP_CMAC _contest23__GetSessionIdResponse {
      public:
        /// Required element 'contest23:GetSessionIdResult' of XSD type 'xsd:string'
        std::string GetSessionIdResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_C2__contest23__GetSessionIdResponse
        virtual int soap_type(void) const { return SOAP_TYPE_C2__contest23__GetSessionIdResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _contest23__GetSessionIdResponse, default initialized and not managed by a soap context
        virtual _contest23__GetSessionIdResponse *soap_alloc(void) const { return SOAP_NEW(_contest23__GetSessionIdResponse); }
      public:
        /// Constructor with initializations
        _contest23__GetSessionIdResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_contest23__GetSessionIdResponse() { }
        /// Friend allocator used by soap_new__contest23__GetSessionIdResponse(struct soap*, int)
        friend SOAP_FMAC1 _contest23__GetSessionIdResponse * SOAP_FMAC2 soap_instantiate__contest23__GetSessionIdResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:381 */
#ifndef SOAP_TYPE_C2__contest23__addAndGetQsos
#define SOAP_TYPE_C2__contest23__addAndGetQsos (66)
/* complex XSD type 'contest23:addAndGetQsos': */
class SOAP_CMAC _contest23__addAndGetQsos {
      public:
        /// Required element 'contest23:SessionId' of XSD type 'xsd:string'
        std::string SessionId;
        /// Required element 'contest23:QsoAddArray' of XSD type 'contest25:ArrayOfQso'
        contest25__ArrayOfQso *QsoAddArray;
        /// Required element 'contest23:OldState' of XSD type 'xsd:int'
        int OldState;
        /// Required element 'contest23:MaxRequested' of XSD type 'xsd:int'
        int MaxRequested;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_C2__contest23__addAndGetQsos
        virtual int soap_type(void) const { return SOAP_TYPE_C2__contest23__addAndGetQsos; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _contest23__addAndGetQsos, default initialized and not managed by a soap context
        virtual _contest23__addAndGetQsos *soap_alloc(void) const { return SOAP_NEW(_contest23__addAndGetQsos); }
      public:
        /// Constructor with initializations
        _contest23__addAndGetQsos()
        {
          QsoAddArray = (contest25__ArrayOfQso *)0;
          OldState = (int)0;
          MaxRequested = (int)0;
          soap = (struct soap *)0;
        }
        virtual ~_contest23__addAndGetQsos() { }
        /// Friend allocator used by soap_new__contest23__addAndGetQsos(struct soap*, int)
        friend SOAP_FMAC1 _contest23__addAndGetQsos * SOAP_FMAC2 soap_instantiate__contest23__addAndGetQsos(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:384 */
#ifndef SOAP_TYPE_C2__contest23__addAndGetQsosResponse
#define SOAP_TYPE_C2__contest23__addAndGetQsosResponse (67)
/* complex XSD type 'contest23:addAndGetQsosResponse': */
class SOAP_CMAC _contest23__addAndGetQsosResponse {
      public:
        /// Required element 'contest23:addAndGetQsosResult' of XSD type 'contest25:QsoUpdate'
        contest25__QsoUpdate *addAndGetQsosResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_C2__contest23__addAndGetQsosResponse
        virtual int soap_type(void) const { return SOAP_TYPE_C2__contest23__addAndGetQsosResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _contest23__addAndGetQsosResponse, default initialized and not managed by a soap context
        virtual _contest23__addAndGetQsosResponse *soap_alloc(void) const { return SOAP_NEW(_contest23__addAndGetQsosResponse); }
      public:
        /// Constructor with initializations
        _contest23__addAndGetQsosResponse()
        {
          addAndGetQsosResult = (contest25__QsoUpdate *)0;
          soap = (struct soap *)0;
        }
        virtual ~_contest23__addAndGetQsosResponse() { }
        /// Friend allocator used by soap_new__contest23__addAndGetQsosResponse(struct soap*, int)
        friend SOAP_FMAC1 _contest23__addAndGetQsosResponse * SOAP_FMAC2 soap_instantiate__contest23__addAndGetQsosResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:387 */
#ifndef SOAP_TYPE_C2__contest23__AddAndGetLogSummary
#define SOAP_TYPE_C2__contest23__AddAndGetLogSummary (68)
/* complex XSD type 'contest23:AddAndGetLogSummary': */
class SOAP_CMAC _contest23__AddAndGetLogSummary {
      public:
        /// Required element 'contest23:SessionId' of XSD type 'xsd:string'
        std::string SessionId;
        /// Required element 'contest23:QsoAddArray' of XSD type 'contest25:ArrayOfQso'
        contest25__ArrayOfQso *QsoAddArray;
        /// Required element 'contest23:OldState' of XSD type 'xsd:int'
        int OldState;
        /// Required element 'contest23:MaxRequested' of XSD type 'xsd:int'
        int MaxRequested;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_C2__contest23__AddAndGetLogSummary
        virtual int soap_type(void) const { return SOAP_TYPE_C2__contest23__AddAndGetLogSummary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _contest23__AddAndGetLogSummary, default initialized and not managed by a soap context
        virtual _contest23__AddAndGetLogSummary *soap_alloc(void) const { return SOAP_NEW(_contest23__AddAndGetLogSummary); }
      public:
        /// Constructor with initializations
        _contest23__AddAndGetLogSummary()
        {
          QsoAddArray = (contest25__ArrayOfQso *)0;
          OldState = (int)0;
          MaxRequested = (int)0;
          soap = (struct soap *)0;
        }
        virtual ~_contest23__AddAndGetLogSummary() { }
        /// Friend allocator used by soap_new__contest23__AddAndGetLogSummary(struct soap*, int)
        friend SOAP_FMAC1 _contest23__AddAndGetLogSummary * SOAP_FMAC2 soap_instantiate__contest23__AddAndGetLogSummary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:390 */
#ifndef SOAP_TYPE_C2__contest23__AddAndGetLogSummaryResponse
#define SOAP_TYPE_C2__contest23__AddAndGetLogSummaryResponse (69)
/* complex XSD type 'contest23:AddAndGetLogSummaryResponse': */
class SOAP_CMAC _contest23__AddAndGetLogSummaryResponse {
      public:
        /// Required element 'contest23:AddAndGetLogSummaryResult' of XSD type 'contest25:LogSummary'
        contest25__LogSummary *AddAndGetLogSummaryResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_C2__contest23__AddAndGetLogSummaryResponse
        virtual int soap_type(void) const { return SOAP_TYPE_C2__contest23__AddAndGetLogSummaryResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _contest23__AddAndGetLogSummaryResponse, default initialized and not managed by a soap context
        virtual _contest23__AddAndGetLogSummaryResponse *soap_alloc(void) const { return SOAP_NEW(_contest23__AddAndGetLogSummaryResponse); }
      public:
        /// Constructor with initializations
        _contest23__AddAndGetLogSummaryResponse()
        {
          AddAndGetLogSummaryResult = (contest25__LogSummary *)0;
          soap = (struct soap *)0;
        }
        virtual ~_contest23__AddAndGetLogSummaryResponse() { }
        /// Friend allocator used by soap_new__contest23__AddAndGetLogSummaryResponse(struct soap*, int)
        friend SOAP_FMAC1 _contest23__AddAndGetLogSummaryResponse * SOAP_FMAC2 soap_instantiate__contest23__AddAndGetLogSummaryResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:393 */
#ifndef SOAP_TYPE_C2__contest23__getQsosByKeyArray
#define SOAP_TYPE_C2__contest23__getQsosByKeyArray (70)
/* complex XSD type 'contest23:getQsosByKeyArray': */
class SOAP_CMAC _contest23__getQsosByKeyArray {
      public:
        /// Required element 'contest23:SessionId' of XSD type 'xsd:string'
        std::string SessionId;
        /// Required element 'contest23:QsoKeyArray' of XSD type 'contest26:ArrayOfstring'
        contest26__ArrayOfstring *QsoKeyArray;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_C2__contest23__getQsosByKeyArray
        virtual int soap_type(void) const { return SOAP_TYPE_C2__contest23__getQsosByKeyArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _contest23__getQsosByKeyArray, default initialized and not managed by a soap context
        virtual _contest23__getQsosByKeyArray *soap_alloc(void) const { return SOAP_NEW(_contest23__getQsosByKeyArray); }
      public:
        /// Constructor with initializations
        _contest23__getQsosByKeyArray()
        {
          QsoKeyArray = (contest26__ArrayOfstring *)0;
          soap = (struct soap *)0;
        }
        virtual ~_contest23__getQsosByKeyArray() { }
        /// Friend allocator used by soap_new__contest23__getQsosByKeyArray(struct soap*, int)
        friend SOAP_FMAC1 _contest23__getQsosByKeyArray * SOAP_FMAC2 soap_instantiate__contest23__getQsosByKeyArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:396 */
#ifndef SOAP_TYPE_C2__contest23__getQsosByKeyArrayResponse
#define SOAP_TYPE_C2__contest23__getQsosByKeyArrayResponse (71)
/* complex XSD type 'contest23:getQsosByKeyArrayResponse': */
class SOAP_CMAC _contest23__getQsosByKeyArrayResponse {
      public:
        /// Required element 'contest23:getQsosByKeyArrayResult' of XSD type 'contest25:QsoUpdate'
        contest25__QsoUpdate *getQsosByKeyArrayResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_C2__contest23__getQsosByKeyArrayResponse
        virtual int soap_type(void) const { return SOAP_TYPE_C2__contest23__getQsosByKeyArrayResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _contest23__getQsosByKeyArrayResponse, default initialized and not managed by a soap context
        virtual _contest23__getQsosByKeyArrayResponse *soap_alloc(void) const { return SOAP_NEW(_contest23__getQsosByKeyArrayResponse); }
      public:
        /// Constructor with initializations
        _contest23__getQsosByKeyArrayResponse()
        {
          getQsosByKeyArrayResult = (contest25__QsoUpdate *)0;
          soap = (struct soap *)0;
        }
        virtual ~_contest23__getQsosByKeyArrayResponse() { }
        /// Friend allocator used by soap_new__contest23__getQsosByKeyArrayResponse(struct soap*, int)
        friend SOAP_FMAC1 _contest23__getQsosByKeyArrayResponse * SOAP_FMAC2 soap_instantiate__contest23__getQsosByKeyArrayResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:399 */
#ifndef SOAP_TYPE_C2__contest23__ColumnNamesToIndices
#define SOAP_TYPE_C2__contest23__ColumnNamesToIndices (72)
/* complex XSD type 'contest23:ColumnNamesToIndices': */
class SOAP_CMAC _contest23__ColumnNamesToIndices {
      public:
        /// Required element 'contest23:SessionId' of XSD type 'xsd:string'
        std::string SessionId;
        /// Required element 'contest23:ColumnNames' of XSD type 'contest26:ArrayOfstring'
        contest26__ArrayOfstring *ColumnNames;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_C2__contest23__ColumnNamesToIndices
        virtual int soap_type(void) const { return SOAP_TYPE_C2__contest23__ColumnNamesToIndices; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _contest23__ColumnNamesToIndices, default initialized and not managed by a soap context
        virtual _contest23__ColumnNamesToIndices *soap_alloc(void) const { return SOAP_NEW(_contest23__ColumnNamesToIndices); }
      public:
        /// Constructor with initializations
        _contest23__ColumnNamesToIndices()
        {
          ColumnNames = (contest26__ArrayOfstring *)0;
          soap = (struct soap *)0;
        }
        virtual ~_contest23__ColumnNamesToIndices() { }
        /// Friend allocator used by soap_new__contest23__ColumnNamesToIndices(struct soap*, int)
        friend SOAP_FMAC1 _contest23__ColumnNamesToIndices * SOAP_FMAC2 soap_instantiate__contest23__ColumnNamesToIndices(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:402 */
#ifndef SOAP_TYPE_C2__contest23__ColumnNamesToIndicesResponse
#define SOAP_TYPE_C2__contest23__ColumnNamesToIndicesResponse (73)
/* complex XSD type 'contest23:ColumnNamesToIndicesResponse': */
class SOAP_CMAC _contest23__ColumnNamesToIndicesResponse {
      public:
        /// Required element 'contest23:ColumnNamesToIndicesResult' of XSD type 'contest26:ArrayOfint'
        contest26__ArrayOfint *ColumnNamesToIndicesResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_C2__contest23__ColumnNamesToIndicesResponse
        virtual int soap_type(void) const { return SOAP_TYPE_C2__contest23__ColumnNamesToIndicesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _contest23__ColumnNamesToIndicesResponse, default initialized and not managed by a soap context
        virtual _contest23__ColumnNamesToIndicesResponse *soap_alloc(void) const { return SOAP_NEW(_contest23__ColumnNamesToIndicesResponse); }
      public:
        /// Constructor with initializations
        _contest23__ColumnNamesToIndicesResponse()
        {
          ColumnNamesToIndicesResult = (contest26__ArrayOfint *)0;
          soap = (struct soap *)0;
        }
        virtual ~_contest23__ColumnNamesToIndicesResponse() { }
        /// Friend allocator used by soap_new__contest23__ColumnNamesToIndicesResponse(struct soap*, int)
        friend SOAP_FMAC1 _contest23__ColumnNamesToIndicesResponse * SOAP_FMAC2 soap_instantiate__contest23__ColumnNamesToIndicesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:405 */
#ifndef SOAP_TYPE_C2__contest23__ExchangeFrequencies
#define SOAP_TYPE_C2__contest23__ExchangeFrequencies (74)
/* complex XSD type 'contest23:ExchangeFrequencies': */
class SOAP_CMAC _contest23__ExchangeFrequencies {
      public:
        /// Required element 'contest23:IncomingFreqs' of XSD type 'contest25:ArrayOfRigFrequency'
        contest25__ArrayOfRigFrequency *IncomingFreqs;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_C2__contest23__ExchangeFrequencies
        virtual int soap_type(void) const { return SOAP_TYPE_C2__contest23__ExchangeFrequencies; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _contest23__ExchangeFrequencies, default initialized and not managed by a soap context
        virtual _contest23__ExchangeFrequencies *soap_alloc(void) const { return SOAP_NEW(_contest23__ExchangeFrequencies); }
      public:
        /// Constructor with initializations
        _contest23__ExchangeFrequencies()
        {
          IncomingFreqs = (contest25__ArrayOfRigFrequency *)0;
          soap = (struct soap *)0;
        }
        virtual ~_contest23__ExchangeFrequencies() { }
        /// Friend allocator used by soap_new__contest23__ExchangeFrequencies(struct soap*, int)
        friend SOAP_FMAC1 _contest23__ExchangeFrequencies * SOAP_FMAC2 soap_instantiate__contest23__ExchangeFrequencies(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:408 */
#ifndef SOAP_TYPE_C2__contest23__ExchangeFrequenciesResponse
#define SOAP_TYPE_C2__contest23__ExchangeFrequenciesResponse (75)
/* complex XSD type 'contest23:ExchangeFrequenciesResponse': */
class SOAP_CMAC _contest23__ExchangeFrequenciesResponse {
      public:
        /// Required element 'contest23:ExchangeFrequenciesResult' of XSD type 'contest25:ArrayOfRigFrequency'
        contest25__ArrayOfRigFrequency *ExchangeFrequenciesResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_C2__contest23__ExchangeFrequenciesResponse
        virtual int soap_type(void) const { return SOAP_TYPE_C2__contest23__ExchangeFrequenciesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _contest23__ExchangeFrequenciesResponse, default initialized and not managed by a soap context
        virtual _contest23__ExchangeFrequenciesResponse *soap_alloc(void) const { return SOAP_NEW(_contest23__ExchangeFrequenciesResponse); }
      public:
        /// Constructor with initializations
        _contest23__ExchangeFrequenciesResponse()
        {
          ExchangeFrequenciesResult = (contest25__ArrayOfRigFrequency *)0;
          soap = (struct soap *)0;
        }
        virtual ~_contest23__ExchangeFrequenciesResponse() { }
        /// Friend allocator used by soap_new__contest23__ExchangeFrequenciesResponse(struct soap*, int)
        friend SOAP_FMAC1 _contest23__ExchangeFrequenciesResponse * SOAP_FMAC2 soap_instantiate__contest23__ExchangeFrequenciesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:1353 */
#ifndef SOAP_TYPE_C2___contest23__GetSessionId
#define SOAP_TYPE_C2___contest23__GetSessionId (100)
/* Wrapper: */
struct __contest23__GetSessionId {
      public:
        /** Optional element 'contest23:GetSessionId' of XSD type 'contest23:GetSessionId' */
        _contest23__GetSessionId *contest23__GetSessionId;
      public:
        /** Return unique type id SOAP_TYPE_C2___contest23__GetSessionId */
        int soap_type() const { return SOAP_TYPE_C2___contest23__GetSessionId; }
        /** Constructor with member initializations */
        __contest23__GetSessionId()
        {
          contest23__GetSessionId = (_contest23__GetSessionId *)0;
        }
        /** Friend allocator used by soap_new___contest23__GetSessionId(struct soap*, int) */
        friend SOAP_FMAC1 __contest23__GetSessionId * SOAP_FMAC2 soap_instantiate___contest23__GetSessionId(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:1419 */
#ifndef SOAP_TYPE_C2___contest23__addAndGetQsos
#define SOAP_TYPE_C2___contest23__addAndGetQsos (104)
/* Wrapper: */
struct __contest23__addAndGetQsos {
      public:
        /** Optional element 'contest23:addAndGetQsos' of XSD type 'contest23:addAndGetQsos' */
        _contest23__addAndGetQsos *contest23__addAndGetQsos;
      public:
        /** Return unique type id SOAP_TYPE_C2___contest23__addAndGetQsos */
        int soap_type() const { return SOAP_TYPE_C2___contest23__addAndGetQsos; }
        /** Constructor with member initializations */
        __contest23__addAndGetQsos()
        {
          contest23__addAndGetQsos = (_contest23__addAndGetQsos *)0;
        }
        /** Friend allocator used by soap_new___contest23__addAndGetQsos(struct soap*, int) */
        friend SOAP_FMAC1 __contest23__addAndGetQsos * SOAP_FMAC2 soap_instantiate___contest23__addAndGetQsos(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:1485 */
#ifndef SOAP_TYPE_C2___contest23__AddAndGetLogSummary
#define SOAP_TYPE_C2___contest23__AddAndGetLogSummary (108)
/* Wrapper: */
struct __contest23__AddAndGetLogSummary {
      public:
        /** Optional element 'contest23:AddAndGetLogSummary' of XSD type 'contest23:AddAndGetLogSummary' */
        _contest23__AddAndGetLogSummary *contest23__AddAndGetLogSummary;
      public:
        /** Return unique type id SOAP_TYPE_C2___contest23__AddAndGetLogSummary */
        int soap_type() const { return SOAP_TYPE_C2___contest23__AddAndGetLogSummary; }
        /** Constructor with member initializations */
        __contest23__AddAndGetLogSummary()
        {
          contest23__AddAndGetLogSummary = (_contest23__AddAndGetLogSummary *)0;
        }
        /** Friend allocator used by soap_new___contest23__AddAndGetLogSummary(struct soap*, int) */
        friend SOAP_FMAC1 __contest23__AddAndGetLogSummary * SOAP_FMAC2 soap_instantiate___contest23__AddAndGetLogSummary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:1551 */
#ifndef SOAP_TYPE_C2___contest23__getQsosByKeyArray
#define SOAP_TYPE_C2___contest23__getQsosByKeyArray (112)
/* Wrapper: */
struct __contest23__getQsosByKeyArray {
      public:
        /** Optional element 'contest23:getQsosByKeyArray' of XSD type 'contest23:getQsosByKeyArray' */
        _contest23__getQsosByKeyArray *contest23__getQsosByKeyArray;
      public:
        /** Return unique type id SOAP_TYPE_C2___contest23__getQsosByKeyArray */
        int soap_type() const { return SOAP_TYPE_C2___contest23__getQsosByKeyArray; }
        /** Constructor with member initializations */
        __contest23__getQsosByKeyArray()
        {
          contest23__getQsosByKeyArray = (_contest23__getQsosByKeyArray *)0;
        }
        /** Friend allocator used by soap_new___contest23__getQsosByKeyArray(struct soap*, int) */
        friend SOAP_FMAC1 __contest23__getQsosByKeyArray * SOAP_FMAC2 soap_instantiate___contest23__getQsosByKeyArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:1617 */
#ifndef SOAP_TYPE_C2___contest23__ColumnNamesToIndices
#define SOAP_TYPE_C2___contest23__ColumnNamesToIndices (116)
/* Wrapper: */
struct __contest23__ColumnNamesToIndices {
      public:
        /** Optional element 'contest23:ColumnNamesToIndices' of XSD type 'contest23:ColumnNamesToIndices' */
        _contest23__ColumnNamesToIndices *contest23__ColumnNamesToIndices;
      public:
        /** Return unique type id SOAP_TYPE_C2___contest23__ColumnNamesToIndices */
        int soap_type() const { return SOAP_TYPE_C2___contest23__ColumnNamesToIndices; }
        /** Constructor with member initializations */
        __contest23__ColumnNamesToIndices()
        {
          contest23__ColumnNamesToIndices = (_contest23__ColumnNamesToIndices *)0;
        }
        /** Friend allocator used by soap_new___contest23__ColumnNamesToIndices(struct soap*, int) */
        friend SOAP_FMAC1 __contest23__ColumnNamesToIndices * SOAP_FMAC2 soap_instantiate___contest23__ColumnNamesToIndices(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:1683 */
#ifndef SOAP_TYPE_C2___contest23__ExchangeFrequencies
#define SOAP_TYPE_C2___contest23__ExchangeFrequencies (120)
/* Wrapper: */
struct __contest23__ExchangeFrequencies {
      public:
        /** Optional element 'contest23:ExchangeFrequencies' of XSD type 'contest23:ExchangeFrequencies' */
        _contest23__ExchangeFrequencies *contest23__ExchangeFrequencies;
      public:
        /** Return unique type id SOAP_TYPE_C2___contest23__ExchangeFrequencies */
        int soap_type() const { return SOAP_TYPE_C2___contest23__ExchangeFrequencies; }
        /** Constructor with member initializations */
        __contest23__ExchangeFrequencies()
        {
          contest23__ExchangeFrequencies = (_contest23__ExchangeFrequencies *)0;
        }
        /** Friend allocator used by soap_new___contest23__ExchangeFrequencies(struct soap*, int) */
        friend SOAP_FMAC1 __contest23__ExchangeFrequencies * SOAP_FMAC2 soap_instantiate___contest23__ExchangeFrequencies(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos2.h:1910 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_C2_SOAP_ENV__Header
#define SOAP_TYPE_C2_SOAP_ENV__Header (121)
/* SOAP_ENV__Header: */
struct SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_C2_SOAP_ENV__Header */
        int soap_type() const { return SOAP_TYPE_C2_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header()
        {
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Header(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* ContestQsos2.h:1910 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_C2_SOAP_ENV__Code
#define SOAP_TYPE_C2_SOAP_ENV__Code (122)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XSD type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_C2_SOAP_ENV__Code */
        int soap_type() const { return SOAP_TYPE_C2_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code()
        {
          SOAP_ENV__Value = (char *)0;
          SOAP_ENV__Subcode = (struct SOAP_ENV__Code *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Code(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* ContestQsos2.h:1910 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_C2_SOAP_ENV__Detail
#define SOAP_TYPE_C2_SOAP_ENV__Detail (124)
/* SOAP_ENV__Detail: */
struct SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_T assigned to __type */
        /** Do not create a cyclic data structure throught this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_C2_SOAP_ENV__Detail */
        int soap_type() const { return SOAP_TYPE_C2_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail()
        {
          __any = (char *)0;
          __type = 0;
          fault = NULL;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Detail(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* ContestQsos2.h:1910 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_C2_SOAP_ENV__Reason
#define SOAP_TYPE_C2_SOAP_ENV__Reason (127)
/* SOAP_ENV__Reason: */
struct SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XSD type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_C2_SOAP_ENV__Reason */
        int soap_type() const { return SOAP_TYPE_C2_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason()
        {
          SOAP_ENV__Text = (char *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Reason(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* ContestQsos2.h:1910 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_C2_SOAP_ENV__Fault
#define SOAP_TYPE_C2_SOAP_ENV__Fault (128)
/* SOAP_ENV__Fault: */
struct SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XSD type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XSD type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XSD type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XSD type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XSD type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XSD type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_C2_SOAP_ENV__Fault */
        int soap_type() const { return SOAP_TYPE_C2_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault()
        {
          faultcode = (char *)0;
          faultstring = (char *)0;
          faultactor = (char *)0;
          detail = (struct SOAP_ENV__Detail *)0;
          SOAP_ENV__Code = (struct SOAP_ENV__Code *)0;
          SOAP_ENV__Reason = (struct SOAP_ENV__Reason *)0;
          SOAP_ENV__Node = (char *)0;
          SOAP_ENV__Role = (char *)0;
          SOAP_ENV__Detail = (struct SOAP_ENV__Detail *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Fault(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* ContestQsos2.h:101 */
#ifndef SOAP_TYPE_C2__QName
#define SOAP_TYPE_C2__QName (5)
typedef char *_QName;
#endif

/* ContestQsos2.h:101 */
#ifndef SOAP_TYPE_C2__XML
#define SOAP_TYPE_C2__XML (6)
typedef char *_XML;
#endif

/* ContestQsos2.h:176 */
#ifndef SOAP_TYPE_C2_xsd__byte
#define SOAP_TYPE_C2_xsd__byte (19)
typedef char xsd__byte;
#endif

/* ContestQsos2.h:179 */
#ifndef SOAP_TYPE_C2_xsd__unsignedByte
#define SOAP_TYPE_C2_xsd__unsignedByte (20)
typedef unsigned char xsd__unsignedByte;
#endif

/* ContestQsos2.h:182 */
#ifndef SOAP_TYPE_C2_xsd__ID
#define SOAP_TYPE_C2_xsd__ID (21)
typedef std::string xsd__ID;
#endif

/* ContestQsos2.h:192 */
#ifndef SOAP_TYPE_C2_xsd__IDREF
#define SOAP_TYPE_C2_xsd__IDREF (23)
typedef std::string xsd__IDREF;
#endif

/* ContestQsos2.h:209 */
#ifndef SOAP_TYPE_C2_xsd__anyURI
#define SOAP_TYPE_C2_xsd__anyURI (26)
typedef std::string xsd__anyURI;
#endif

/* ContestQsos2.h:247 */
#ifndef SOAP_TYPE_C2_xsd__decimal
#define SOAP_TYPE_C2_xsd__decimal (34)
typedef std::string xsd__decimal;
#endif

/* ContestQsos2.h:264 */
#ifndef SOAP_TYPE_C2_xsd__duration
#define SOAP_TYPE_C2_xsd__duration (38)
typedef std::string xsd__duration;
#endif

/* ContestQsos2.h:452 */
#ifndef SOAP_TYPE_C2_contest24__char
#define SOAP_TYPE_C2_contest24__char (76)
typedef int contest24__char;
#endif

/* ContestQsos2.h:465 */
#ifndef SOAP_TYPE_C2_contest24__duration
#define SOAP_TYPE_C2_contest24__duration (78)
typedef std::string contest24__duration;
#endif

/* ContestQsos2.h:477 */
#ifndef SOAP_TYPE_C2_contest24__guid
#define SOAP_TYPE_C2_contest24__guid (80)
typedef std::string contest24__guid;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* xsd__byte has binding name 'xsd__byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_C2_xsd__byte
#define SOAP_TYPE_C2_xsd__byte (19)
#endif

/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_C2_byte
#define SOAP_TYPE_C2_byte (3)
#endif

/* short has binding name 'short' for type 'xsd:short' */
#ifndef SOAP_TYPE_C2_short
#define SOAP_TYPE_C2_short (46)
#endif

/* contest24__char has binding name 'contest24__char' for type 'contest24:char' */
#ifndef SOAP_TYPE_C2_contest24__char
#define SOAP_TYPE_C2_contest24__char (76)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_C2_int
#define SOAP_TYPE_C2_int (1)
#endif

/* LONG64 has binding name 'LONG64' for type 'xsd:long' */
#ifndef SOAP_TYPE_C2_LONG64
#define SOAP_TYPE_C2_LONG64 (44)
#endif

/* float has binding name 'float' for type 'xsd:float' */
#ifndef SOAP_TYPE_C2_float
#define SOAP_TYPE_C2_float (41)
#endif

/* double has binding name 'double' for type 'xsd:double' */
#ifndef SOAP_TYPE_C2_double
#define SOAP_TYPE_C2_double (37)
#endif

/* xsd__unsignedByte has binding name 'xsd__unsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_C2_xsd__unsignedByte
#define SOAP_TYPE_C2_xsd__unsignedByte (20)
#endif

/* unsigned char has binding name 'unsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_C2_unsignedByte
#define SOAP_TYPE_C2_unsignedByte (17)
#endif

/* unsigned short has binding name 'unsignedShort' for type 'xsd:unsignedShort' */
#ifndef SOAP_TYPE_C2_unsignedShort
#define SOAP_TYPE_C2_unsignedShort (53)
#endif

/* unsigned int has binding name 'unsignedInt' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_C2_unsignedInt
#define SOAP_TYPE_C2_unsignedInt (16)
#endif

/* ULONG64 has binding name 'ULONG64' for type 'xsd:unsignedLong' */
#ifndef SOAP_TYPE_C2_ULONG64
#define SOAP_TYPE_C2_ULONG64 (51)
#endif

/* time_t has binding name 'dateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_C2_dateTime
#define SOAP_TYPE_C2_dateTime (33)
#endif

/* bool has binding name 'bool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_C2_bool
#define SOAP_TYPE_C2_bool (30)
#endif

/* contest24__guid__ has binding name 'contest24__guid__' for type 'contest24:guid' */
#ifndef SOAP_TYPE_C2_contest24__guid__
#define SOAP_TYPE_C2_contest24__guid__ (81)
#endif

/* contest24__guid has binding name 'contest24__guid' for type 'contest24:guid' */
#ifndef SOAP_TYPE_C2_contest24__guid
#define SOAP_TYPE_C2_contest24__guid (80)
#endif

/* contest24__duration__ has binding name 'contest24__duration__' for type 'contest24:duration' */
#ifndef SOAP_TYPE_C2_contest24__duration__
#define SOAP_TYPE_C2_contest24__duration__ (79)
#endif

/* contest24__duration has binding name 'contest24__duration' for type 'contest24:duration' */
#ifndef SOAP_TYPE_C2_contest24__duration
#define SOAP_TYPE_C2_contest24__duration (78)
#endif

/* contest24__char__ has binding name 'contest24__char__' for type 'contest24:char' */
#ifndef SOAP_TYPE_C2_contest24__char__
#define SOAP_TYPE_C2_contest24__char__ (77)
#endif

/* _contest23__ExchangeFrequenciesResponse has binding name '_contest23__ExchangeFrequenciesResponse' for type '' */
#ifndef SOAP_TYPE_C2__contest23__ExchangeFrequenciesResponse
#define SOAP_TYPE_C2__contest23__ExchangeFrequenciesResponse (75)
#endif

/* _contest23__ExchangeFrequencies has binding name '_contest23__ExchangeFrequencies' for type '' */
#ifndef SOAP_TYPE_C2__contest23__ExchangeFrequencies
#define SOAP_TYPE_C2__contest23__ExchangeFrequencies (74)
#endif

/* _contest23__ColumnNamesToIndicesResponse has binding name '_contest23__ColumnNamesToIndicesResponse' for type '' */
#ifndef SOAP_TYPE_C2__contest23__ColumnNamesToIndicesResponse
#define SOAP_TYPE_C2__contest23__ColumnNamesToIndicesResponse (73)
#endif

/* _contest23__ColumnNamesToIndices has binding name '_contest23__ColumnNamesToIndices' for type '' */
#ifndef SOAP_TYPE_C2__contest23__ColumnNamesToIndices
#define SOAP_TYPE_C2__contest23__ColumnNamesToIndices (72)
#endif

/* _contest23__getQsosByKeyArrayResponse has binding name '_contest23__getQsosByKeyArrayResponse' for type '' */
#ifndef SOAP_TYPE_C2__contest23__getQsosByKeyArrayResponse
#define SOAP_TYPE_C2__contest23__getQsosByKeyArrayResponse (71)
#endif

/* _contest23__getQsosByKeyArray has binding name '_contest23__getQsosByKeyArray' for type '' */
#ifndef SOAP_TYPE_C2__contest23__getQsosByKeyArray
#define SOAP_TYPE_C2__contest23__getQsosByKeyArray (70)
#endif

/* _contest23__AddAndGetLogSummaryResponse has binding name '_contest23__AddAndGetLogSummaryResponse' for type '' */
#ifndef SOAP_TYPE_C2__contest23__AddAndGetLogSummaryResponse
#define SOAP_TYPE_C2__contest23__AddAndGetLogSummaryResponse (69)
#endif

/* _contest23__AddAndGetLogSummary has binding name '_contest23__AddAndGetLogSummary' for type '' */
#ifndef SOAP_TYPE_C2__contest23__AddAndGetLogSummary
#define SOAP_TYPE_C2__contest23__AddAndGetLogSummary (68)
#endif

/* _contest23__addAndGetQsosResponse has binding name '_contest23__addAndGetQsosResponse' for type '' */
#ifndef SOAP_TYPE_C2__contest23__addAndGetQsosResponse
#define SOAP_TYPE_C2__contest23__addAndGetQsosResponse (67)
#endif

/* _contest23__addAndGetQsos has binding name '_contest23__addAndGetQsos' for type '' */
#ifndef SOAP_TYPE_C2__contest23__addAndGetQsos
#define SOAP_TYPE_C2__contest23__addAndGetQsos (66)
#endif

/* _contest23__GetSessionIdResponse has binding name '_contest23__GetSessionIdResponse' for type '' */
#ifndef SOAP_TYPE_C2__contest23__GetSessionIdResponse
#define SOAP_TYPE_C2__contest23__GetSessionIdResponse (65)
#endif

/* _contest23__GetSessionId has binding name '_contest23__GetSessionId' for type '' */
#ifndef SOAP_TYPE_C2__contest23__GetSessionId
#define SOAP_TYPE_C2__contest23__GetSessionId (64)
#endif

/* contest25__RigFrequency has binding name 'contest25__RigFrequency' for type 'contest25:RigFrequency' */
#ifndef SOAP_TYPE_C2_contest25__RigFrequency
#define SOAP_TYPE_C2_contest25__RigFrequency (63)
#endif

/* contest25__ArrayOfRigFrequency has binding name 'contest25__ArrayOfRigFrequency' for type 'contest25:ArrayOfRigFrequency' */
#ifndef SOAP_TYPE_C2_contest25__ArrayOfRigFrequency
#define SOAP_TYPE_C2_contest25__ArrayOfRigFrequency (62)
#endif

/* contest25__QsoIdVersion has binding name 'contest25__QsoIdVersion' for type 'contest25:QsoIdVersion' */
#ifndef SOAP_TYPE_C2_contest25__QsoIdVersion
#define SOAP_TYPE_C2_contest25__QsoIdVersion (61)
#endif

/* contest25__ArrayOfQsoIdVersion has binding name 'contest25__ArrayOfQsoIdVersion' for type 'contest25:ArrayOfQsoIdVersion' */
#ifndef SOAP_TYPE_C2_contest25__ArrayOfQsoIdVersion
#define SOAP_TYPE_C2_contest25__ArrayOfQsoIdVersion (60)
#endif

/* contest25__LogSummary has binding name 'contest25__LogSummary' for type 'contest25:LogSummary' */
#ifndef SOAP_TYPE_C2_contest25__LogSummary
#define SOAP_TYPE_C2_contest25__LogSummary (59)
#endif

/* contest25__QsoUpdate has binding name 'contest25__QsoUpdate' for type 'contest25:QsoUpdate' */
#ifndef SOAP_TYPE_C2_contest25__QsoUpdate
#define SOAP_TYPE_C2_contest25__QsoUpdate (58)
#endif

/* contest25__Qso has binding name 'contest25__Qso' for type 'contest25:Qso' */
#ifndef SOAP_TYPE_C2_contest25__Qso
#define SOAP_TYPE_C2_contest25__Qso (57)
#endif

/* contest25__ArrayOfQso has binding name 'contest25__ArrayOfQso' for type 'contest25:ArrayOfQso' */
#ifndef SOAP_TYPE_C2_contest25__ArrayOfQso
#define SOAP_TYPE_C2_contest25__ArrayOfQso (56)
#endif

/* contest26__ArrayOfint has binding name 'contest26__ArrayOfint' for type 'contest26:ArrayOfint' */
#ifndef SOAP_TYPE_C2_contest26__ArrayOfint
#define SOAP_TYPE_C2_contest26__ArrayOfint (55)
#endif

/* contest26__ArrayOfstring has binding name 'contest26__ArrayOfstring' for type 'contest26:ArrayOfstring' */
#ifndef SOAP_TYPE_C2_contest26__ArrayOfstring
#define SOAP_TYPE_C2_contest26__ArrayOfstring (54)
#endif

/* xsd__unsignedShort has binding name 'xsd__unsignedShort' for type 'xsd:unsignedShort' */
#ifndef SOAP_TYPE_C2_xsd__unsignedShort
#define SOAP_TYPE_C2_xsd__unsignedShort (52)
#endif

/* xsd__unsignedLong has binding name 'xsd__unsignedLong' for type 'xsd:unsignedLong' */
#ifndef SOAP_TYPE_C2_xsd__unsignedLong
#define SOAP_TYPE_C2_xsd__unsignedLong (50)
#endif

/* xsd__unsignedInt has binding name 'xsd__unsignedInt' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_C2_xsd__unsignedInt
#define SOAP_TYPE_C2_xsd__unsignedInt (49)
#endif

/* xsd__unsignedByte_ has binding name 'xsd__unsignedByte_' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_C2_xsd__unsignedByte_
#define SOAP_TYPE_C2_xsd__unsignedByte_ (48)
#endif

/* xsd__string has binding name 'xsd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_C2_xsd__string
#define SOAP_TYPE_C2_xsd__string (47)
#endif

/* xsd__short has binding name 'xsd__short' for type 'xsd:short' */
#ifndef SOAP_TYPE_C2_xsd__short
#define SOAP_TYPE_C2_xsd__short (45)
#endif

/* xsd__long has binding name 'xsd__long' for type 'xsd:long' */
#ifndef SOAP_TYPE_C2_xsd__long
#define SOAP_TYPE_C2_xsd__long (43)
#endif

/* xsd__int has binding name 'xsd__int' for type 'xsd:int' */
#ifndef SOAP_TYPE_C2_xsd__int
#define SOAP_TYPE_C2_xsd__int (42)
#endif

/* xsd__float has binding name 'xsd__float' for type 'xsd:float' */
#ifndef SOAP_TYPE_C2_xsd__float
#define SOAP_TYPE_C2_xsd__float (40)
#endif

/* xsd__duration_ has binding name 'xsd__duration_' for type 'xsd:duration' */
#ifndef SOAP_TYPE_C2_xsd__duration_
#define SOAP_TYPE_C2_xsd__duration_ (39)
#endif

/* xsd__duration has binding name 'xsd__duration' for type 'xsd:duration' */
#ifndef SOAP_TYPE_C2_xsd__duration
#define SOAP_TYPE_C2_xsd__duration (38)
#endif

/* xsd__double has binding name 'xsd__double' for type 'xsd:double' */
#ifndef SOAP_TYPE_C2_xsd__double
#define SOAP_TYPE_C2_xsd__double (36)
#endif

/* xsd__decimal_ has binding name 'xsd__decimal_' for type 'xsd:decimal' */
#ifndef SOAP_TYPE_C2_xsd__decimal_
#define SOAP_TYPE_C2_xsd__decimal_ (35)
#endif

/* xsd__decimal has binding name 'xsd__decimal' for type 'xsd:decimal' */
#ifndef SOAP_TYPE_C2_xsd__decimal
#define SOAP_TYPE_C2_xsd__decimal (34)
#endif

/* xsd__dateTime has binding name 'xsd__dateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_C2_xsd__dateTime
#define SOAP_TYPE_C2_xsd__dateTime (32)
#endif

/* xsd__byte_ has binding name 'xsd__byte_' for type 'xsd:byte' */
#ifndef SOAP_TYPE_C2_xsd__byte_
#define SOAP_TYPE_C2_xsd__byte_ (31)
#endif

/* xsd__boolean has binding name 'xsd__boolean' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_C2_xsd__boolean
#define SOAP_TYPE_C2_xsd__boolean (29)
#endif

/* xsd__base64Binary_ has binding name 'xsd__base64Binary_' for type 'xsd:base64Binary' */
#ifndef SOAP_TYPE_C2_xsd__base64Binary_
#define SOAP_TYPE_C2_xsd__base64Binary_ (28)
#endif

/* xsd__anyURI_ has binding name 'xsd__anyURI_' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_C2_xsd__anyURI_
#define SOAP_TYPE_C2_xsd__anyURI_ (27)
#endif

/* xsd__anyURI has binding name 'xsd__anyURI' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_C2_xsd__anyURI
#define SOAP_TYPE_C2_xsd__anyURI (26)
#endif

/* xsd__QName_ has binding name 'xsd__QName_' for type 'xsd:QName' */
#ifndef SOAP_TYPE_C2_xsd__QName_
#define SOAP_TYPE_C2_xsd__QName_ (25)
#endif

/* xsd__IDREF_ has binding name 'xsd__IDREF_' for type 'xsd:IDREF' */
#ifndef SOAP_TYPE_C2_xsd__IDREF_
#define SOAP_TYPE_C2_xsd__IDREF_ (24)
#endif

/* xsd__IDREF has binding name 'xsd__IDREF' for type 'xsd:IDREF' */
#ifndef SOAP_TYPE_C2_xsd__IDREF
#define SOAP_TYPE_C2_xsd__IDREF (23)
#endif

/* xsd__ID_ has binding name 'xsd__ID_' for type 'xsd:ID' */
#ifndef SOAP_TYPE_C2_xsd__ID_
#define SOAP_TYPE_C2_xsd__ID_ (22)
#endif

/* xsd__ID has binding name 'xsd__ID' for type 'xsd:ID' */
#ifndef SOAP_TYPE_C2_xsd__ID
#define SOAP_TYPE_C2_xsd__ID (21)
#endif

/* xsd__base64Binary has binding name 'xsd__base64Binary' for type 'xsd:base64Binary' */
#ifndef SOAP_TYPE_C2_xsd__base64Binary
#define SOAP_TYPE_C2_xsd__base64Binary (15)
#endif

/* xsd__QName has binding name 'xsd__QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE_C2_xsd__QName
#define SOAP_TYPE_C2_xsd__QName (14)
#endif

/* std::string has binding name 'std__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_C2_std__string
#define SOAP_TYPE_C2_std__string (13)
#endif

/* xsd__anyType has binding name 'xsd__anyType' for type 'xsd:anyType' */
#ifndef SOAP_TYPE_C2_xsd__anyType
#define SOAP_TYPE_C2_xsd__anyType (11)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_C2_SOAP_ENV__Fault
#define SOAP_TYPE_C2_SOAP_ENV__Fault (128)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_C2_SOAP_ENV__Reason
#define SOAP_TYPE_C2_SOAP_ENV__Reason (127)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_C2_SOAP_ENV__Detail
#define SOAP_TYPE_C2_SOAP_ENV__Detail (124)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_C2_SOAP_ENV__Code
#define SOAP_TYPE_C2_SOAP_ENV__Code (122)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_C2_SOAP_ENV__Header
#define SOAP_TYPE_C2_SOAP_ENV__Header (121)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_C2_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_C2_PointerToSOAP_ENV__Reason (130)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_C2_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_C2_PointerToSOAP_ENV__Detail (129)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_C2_PointerToSOAP_ENV__Code
#define SOAP_TYPE_C2_PointerToSOAP_ENV__Code (123)
#endif

/* _contest23__ExchangeFrequencies * has binding name 'PointerTo_contest23__ExchangeFrequencies' for type '' */
#ifndef SOAP_TYPE_C2_PointerTo_contest23__ExchangeFrequencies
#define SOAP_TYPE_C2_PointerTo_contest23__ExchangeFrequencies (117)
#endif

/* _contest23__ColumnNamesToIndices * has binding name 'PointerTo_contest23__ColumnNamesToIndices' for type '' */
#ifndef SOAP_TYPE_C2_PointerTo_contest23__ColumnNamesToIndices
#define SOAP_TYPE_C2_PointerTo_contest23__ColumnNamesToIndices (113)
#endif

/* _contest23__getQsosByKeyArray * has binding name 'PointerTo_contest23__getQsosByKeyArray' for type '' */
#ifndef SOAP_TYPE_C2_PointerTo_contest23__getQsosByKeyArray
#define SOAP_TYPE_C2_PointerTo_contest23__getQsosByKeyArray (109)
#endif

/* _contest23__AddAndGetLogSummary * has binding name 'PointerTo_contest23__AddAndGetLogSummary' for type '' */
#ifndef SOAP_TYPE_C2_PointerTo_contest23__AddAndGetLogSummary
#define SOAP_TYPE_C2_PointerTo_contest23__AddAndGetLogSummary (105)
#endif

/* _contest23__addAndGetQsos * has binding name 'PointerTo_contest23__addAndGetQsos' for type '' */
#ifndef SOAP_TYPE_C2_PointerTo_contest23__addAndGetQsos
#define SOAP_TYPE_C2_PointerTo_contest23__addAndGetQsos (101)
#endif

/* _contest23__GetSessionId * has binding name 'PointerTo_contest23__GetSessionId' for type '' */
#ifndef SOAP_TYPE_C2_PointerTo_contest23__GetSessionId
#define SOAP_TYPE_C2_PointerTo_contest23__GetSessionId (97)
#endif

/* contest25__ArrayOfRigFrequency * has binding name 'PointerTocontest25__ArrayOfRigFrequency' for type 'contest25:ArrayOfRigFrequency' */
#ifndef SOAP_TYPE_C2_PointerTocontest25__ArrayOfRigFrequency
#define SOAP_TYPE_C2_PointerTocontest25__ArrayOfRigFrequency (96)
#endif

/* contest26__ArrayOfint * has binding name 'PointerTocontest26__ArrayOfint' for type 'contest26:ArrayOfint' */
#ifndef SOAP_TYPE_C2_PointerTocontest26__ArrayOfint
#define SOAP_TYPE_C2_PointerTocontest26__ArrayOfint (95)
#endif

/* contest25__LogSummary * has binding name 'PointerTocontest25__LogSummary' for type 'contest25:LogSummary' */
#ifndef SOAP_TYPE_C2_PointerTocontest25__LogSummary
#define SOAP_TYPE_C2_PointerTocontest25__LogSummary (94)
#endif

/* contest25__QsoUpdate * has binding name 'PointerTocontest25__QsoUpdate' for type 'contest25:QsoUpdate' */
#ifndef SOAP_TYPE_C2_PointerTocontest25__QsoUpdate
#define SOAP_TYPE_C2_PointerTocontest25__QsoUpdate (93)
#endif

/* contest25__RigFrequency * has binding name 'PointerTocontest25__RigFrequency' for type 'contest25:RigFrequency' */
#ifndef SOAP_TYPE_C2_PointerTocontest25__RigFrequency
#define SOAP_TYPE_C2_PointerTocontest25__RigFrequency (91)
#endif

/* contest25__QsoIdVersion * has binding name 'PointerTocontest25__QsoIdVersion' for type 'contest25:QsoIdVersion' */
#ifndef SOAP_TYPE_C2_PointerTocontest25__QsoIdVersion
#define SOAP_TYPE_C2_PointerTocontest25__QsoIdVersion (89)
#endif

/* contest25__ArrayOfQsoIdVersion * has binding name 'PointerTocontest25__ArrayOfQsoIdVersion' for type 'contest25:ArrayOfQsoIdVersion' */
#ifndef SOAP_TYPE_C2_PointerTocontest25__ArrayOfQsoIdVersion
#define SOAP_TYPE_C2_PointerTocontest25__ArrayOfQsoIdVersion (88)
#endif

/* contest25__ArrayOfQso * has binding name 'PointerTocontest25__ArrayOfQso' for type 'contest25:ArrayOfQso' */
#ifndef SOAP_TYPE_C2_PointerTocontest25__ArrayOfQso
#define SOAP_TYPE_C2_PointerTocontest25__ArrayOfQso (87)
#endif

/* contest26__ArrayOfstring * has binding name 'PointerTocontest26__ArrayOfstring' for type 'contest26:ArrayOfstring' */
#ifndef SOAP_TYPE_C2_PointerTocontest26__ArrayOfstring
#define SOAP_TYPE_C2_PointerTocontest26__ArrayOfstring (86)
#endif

/* contest25__Qso * has binding name 'PointerTocontest25__Qso' for type 'contest25:Qso' */
#ifndef SOAP_TYPE_C2_PointerTocontest25__Qso
#define SOAP_TYPE_C2_PointerTocontest25__Qso (84)
#endif

/* unsigned char * has binding name 'PointerTounsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_C2_PointerTounsignedByte
#define SOAP_TYPE_C2_PointerTounsignedByte (18)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE_C2__XML
#define SOAP_TYPE_C2__XML (6)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE_C2__QName
#define SOAP_TYPE_C2__QName (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_C2_string
#define SOAP_TYPE_C2_string (4)
#endif

/* std::vector<contest25__RigFrequency *>  has binding name 'std__vectorTemplateOfPointerTocontest25__RigFrequency' for type 'contest25:RigFrequency' */
#ifndef SOAP_TYPE_C2_std__vectorTemplateOfPointerTocontest25__RigFrequency
#define SOAP_TYPE_C2_std__vectorTemplateOfPointerTocontest25__RigFrequency (92)
#endif

/* std::vector<contest25__QsoIdVersion *>  has binding name 'std__vectorTemplateOfPointerTocontest25__QsoIdVersion' for type 'contest25:QsoIdVersion' */
#ifndef SOAP_TYPE_C2_std__vectorTemplateOfPointerTocontest25__QsoIdVersion
#define SOAP_TYPE_C2_std__vectorTemplateOfPointerTocontest25__QsoIdVersion (90)
#endif

/* std::vector<contest25__Qso *>  has binding name 'std__vectorTemplateOfPointerTocontest25__Qso' for type 'contest25:Qso' */
#ifndef SOAP_TYPE_C2_std__vectorTemplateOfPointerTocontest25__Qso
#define SOAP_TYPE_C2_std__vectorTemplateOfPointerTocontest25__Qso (85)
#endif

/* std::vector<int>  has binding name 'std__vectorTemplateOfint' for type 'xsd:int' */
#ifndef SOAP_TYPE_C2_std__vectorTemplateOfint
#define SOAP_TYPE_C2_std__vectorTemplateOfint (83)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfstd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_C2_std__vectorTemplateOfstd__string
#define SOAP_TYPE_C2_std__vectorTemplateOfstd__string (82)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Server-Side Operations                                                     *
 *                                                                            *
\******************************************************************************/

    /** Web service operation '__contest23__GetSessionId' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __contest23__GetSessionId(struct soap*, _contest23__GetSessionId *contest23__GetSessionId, _contest23__GetSessionIdResponse &contest23__GetSessionIdResponse);
    /** Web service operation '__contest23__addAndGetQsos' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __contest23__addAndGetQsos(struct soap*, _contest23__addAndGetQsos *contest23__addAndGetQsos, _contest23__addAndGetQsosResponse &contest23__addAndGetQsosResponse);
    /** Web service operation '__contest23__AddAndGetLogSummary' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __contest23__AddAndGetLogSummary(struct soap*, _contest23__AddAndGetLogSummary *contest23__AddAndGetLogSummary, _contest23__AddAndGetLogSummaryResponse &contest23__AddAndGetLogSummaryResponse);
    /** Web service operation '__contest23__getQsosByKeyArray' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __contest23__getQsosByKeyArray(struct soap*, _contest23__getQsosByKeyArray *contest23__getQsosByKeyArray, _contest23__getQsosByKeyArrayResponse &contest23__getQsosByKeyArrayResponse);
    /** Web service operation '__contest23__ColumnNamesToIndices' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __contest23__ColumnNamesToIndices(struct soap*, _contest23__ColumnNamesToIndices *contest23__ColumnNamesToIndices, _contest23__ColumnNamesToIndicesResponse &contest23__ColumnNamesToIndicesResponse);
    /** Web service operation '__contest23__ExchangeFrequencies' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __contest23__ExchangeFrequencies(struct soap*, _contest23__ExchangeFrequencies *contest23__ExchangeFrequencies, _contest23__ExchangeFrequenciesResponse &contest23__ExchangeFrequenciesResponse);

/******************************************************************************\
 *                                                                            *
 * Server-Side Skeletons to Invoke Service Operations                         *
 *                                                                            *
\******************************************************************************/

SOAP_FMAC5 int SOAP_FMAC6 C2_serve(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 C2_serve_request(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___contest23__GetSessionId(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___contest23__addAndGetQsos(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___contest23__AddAndGetLogSummary(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___contest23__getQsosByKeyArray(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___contest23__ColumnNamesToIndices(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___contest23__ExchangeFrequencies(struct soap*);

} // namespace C2


#endif

/* End of C2Stub.h */
