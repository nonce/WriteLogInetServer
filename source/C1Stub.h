/* C1Stub.h
   Generated by gSOAP 2.8.32 for ContestQsos.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <vector>
#define SOAP_NAMESPACE_OF_contest2	"urn:xml-soap-Contest"

#ifndef C1Stub_H
#define C1Stub_H
#ifndef WITH_NONAMESPACES
#define WITH_NONAMESPACES
#endif
#ifndef WITH_NOGLOBAL
#define WITH_NOGLOBAL
#endif
#include "stdsoap2.h"
#if GSOAP_VERSION != 20832
# error "GSOAP VERSION 20832 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


namespace C1 {

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class contest2__ArrayOfstring;	/* ContestQsos.h:130 */
class contest2__ArrayOfint;	/* ContestQsos.h:133 */
class contest2__Qso;	/* ContestQsos.h:136 */
class contest2__ArrayOfQso;	/* ContestQsos.h:139 */
class contest2__QsoUpdate;	/* ContestQsos.h:142 */
class contest2__QsoIdVersion;	/* ContestQsos.h:145 */
class contest2__ArrayOfQsoIdVersion;	/* ContestQsos.h:148 */
class contest2__LogSummary;	/* ContestQsos.h:151 */
class contest2__RigFrequency;	/* ContestQsos.h:154 */
class contest2__ArrayOfRigFrequency;	/* ContestQsos.h:157 */
struct contest3__GetSessionIdResponse;	/* ContestQsos.h:439 */
struct contest3__GetSessionId;	/* ContestQsos.h:439 */
struct contest3__AddAndGetLogSummaryResponse;	/* ContestQsos.h:450 */
struct contest3__AddAndGetLogSummary;	/* ContestQsos.h:515 */
struct contest3__addAndGetQsosResponse;	/* ContestQsos.h:526 */
struct contest3__addAndGetQsos;	/* ContestQsos.h:591 */
struct contest3__getQsosByKeyArrayResponse;	/* ContestQsos.h:602 */
struct contest3__getQsosByKeyArray;	/* ContestQsos.h:661 */
struct contest3__ColumnNamesToIndicesResponse;	/* ContestQsos.h:672 */
struct contest3__ColumnNamesToIndices;	/* ContestQsos.h:731 */
struct contest3__ExchangeFrequenciesResponse;	/* ContestQsos.h:742 */
struct contest3__ExchangeFrequencies;	/* ContestQsos.h:798 */

/* ContestQsos.h:130 */
#ifndef SOAP_TYPE_C1_contest2__ArrayOfstring
#define SOAP_TYPE_C1_contest2__ArrayOfstring (8)
/* complex XSD type 'contest2:ArrayOfstring': */
class SOAP_CMAC contest2__ArrayOfstring {
      public:
        /// Optional element 'str_el' of XSD type 'xsd:string'
        std::vector<std::string> str_USCOREel;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_C1_contest2__ArrayOfstring
        virtual int soap_type(void) const { return SOAP_TYPE_C1_contest2__ArrayOfstring; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type contest2__ArrayOfstring, default initialized and not managed by a soap context
        virtual contest2__ArrayOfstring *soap_alloc(void) const { return SOAP_NEW(contest2__ArrayOfstring); }
      public:
        /// Constructor with initializations
        contest2__ArrayOfstring()
        {
          soap = (struct soap *)0;
        }
        virtual ~contest2__ArrayOfstring() { }
        /// Friend allocator used by soap_new_contest2__ArrayOfstring(struct soap*, int)
        friend SOAP_FMAC1 contest2__ArrayOfstring * SOAP_FMAC2 soap_instantiate_contest2__ArrayOfstring(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos.h:133 */
#ifndef SOAP_TYPE_C1_contest2__ArrayOfint
#define SOAP_TYPE_C1_contest2__ArrayOfint (9)
/* complex XSD type 'contest2:ArrayOfint': */
class SOAP_CMAC contest2__ArrayOfint {
      public:
        /// Optional element 'int_el' of XSD type 'xsd:int'
        std::vector<int> int_USCOREel;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_C1_contest2__ArrayOfint
        virtual int soap_type(void) const { return SOAP_TYPE_C1_contest2__ArrayOfint; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type contest2__ArrayOfint, default initialized and not managed by a soap context
        virtual contest2__ArrayOfint *soap_alloc(void) const { return SOAP_NEW(contest2__ArrayOfint); }
      public:
        /// Constructor with initializations
        contest2__ArrayOfint()
        {
          soap = (struct soap *)0;
        }
        virtual ~contest2__ArrayOfint() { }
        /// Friend allocator used by soap_new_contest2__ArrayOfint(struct soap*, int)
        friend SOAP_FMAC1 contest2__ArrayOfint * SOAP_FMAC2 soap_instantiate_contest2__ArrayOfint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos.h:136 */
#ifndef SOAP_TYPE_C1_contest2__Qso
#define SOAP_TYPE_C1_contest2__Qso (10)
/* complex XSD type 'contest2:Qso': */
class SOAP_CMAC contest2__Qso {
      public:
        /// Required element 'time64H' of XSD type 'xsd:int'
        int time64H;
        /// Required element 'time64L' of XSD type 'xsd:int'
        int time64L;
        /// Required element 'xmitFreq' of XSD type 'xsd:double'
        double xmitFreq;
        /// Required element 'recvFreq' of XSD type 'xsd:double'
        double recvFreq;
        /// Required element 'band' of XSD type 'xsd:int'
        int band;
        /// Required element 'station' of XSD type 'xsd:string'
        std::string station;
        /// Required element 'mode' of XSD type 'xsd:int'
        int mode;
        /// Required element 'dupe' of XSD type 'xsd:int'
        int dupe;
        /// Required element 'serial' of XSD type 'xsd:int'
        int serial;
        /// Required element 'qsoparts' of XSD type 'contest2:ArrayOfstring'
        contest2__ArrayOfstring *qsoparts;
        /// Required element 'version' of XSD type 'xsd:int'
        int version;
        /// Required element 'idKey' of XSD type 'xsd:string'
        std::string idKey;
        /// Required element 'updatedBy' of XSD type 'xsd:string'
        std::string updatedBy;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_C1_contest2__Qso
        virtual int soap_type(void) const { return SOAP_TYPE_C1_contest2__Qso; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type contest2__Qso, default initialized and not managed by a soap context
        virtual contest2__Qso *soap_alloc(void) const { return SOAP_NEW(contest2__Qso); }
      public:
        /// Constructor with initializations
        contest2__Qso()
        {
          time64H = (int)0;
          time64L = (int)0;
          xmitFreq = (double)0;
          recvFreq = (double)0;
          band = (int)0;
          mode = (int)0;
          dupe = (int)0;
          serial = (int)0;
          qsoparts = (contest2__ArrayOfstring *)0;
          version = (int)0;
          soap = (struct soap *)0;
        }
        virtual ~contest2__Qso() { }
        /// Friend allocator used by soap_new_contest2__Qso(struct soap*, int)
        friend SOAP_FMAC1 contest2__Qso * SOAP_FMAC2 soap_instantiate_contest2__Qso(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos.h:139 */
#ifndef SOAP_TYPE_C1_contest2__ArrayOfQso
#define SOAP_TYPE_C1_contest2__ArrayOfQso (11)
/* complex XSD type 'contest2:ArrayOfQso': */
class SOAP_CMAC contest2__ArrayOfQso {
      public:
        /// Optional element 'qso_el' of XSD type 'contest2:Qso'
        std::vector<contest2__Qso *> qso_USCOREel;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_C1_contest2__ArrayOfQso
        virtual int soap_type(void) const { return SOAP_TYPE_C1_contest2__ArrayOfQso; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type contest2__ArrayOfQso, default initialized and not managed by a soap context
        virtual contest2__ArrayOfQso *soap_alloc(void) const { return SOAP_NEW(contest2__ArrayOfQso); }
      public:
        /// Constructor with initializations
        contest2__ArrayOfQso()
        {
          soap = (struct soap *)0;
        }
        virtual ~contest2__ArrayOfQso() { }
        /// Friend allocator used by soap_new_contest2__ArrayOfQso(struct soap*, int)
        friend SOAP_FMAC1 contest2__ArrayOfQso * SOAP_FMAC2 soap_instantiate_contest2__ArrayOfQso(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos.h:142 */
#ifndef SOAP_TYPE_C1_contest2__QsoUpdate
#define SOAP_TYPE_C1_contest2__QsoUpdate (12)
/* complex XSD type 'contest2:QsoUpdate': */
class SOAP_CMAC contest2__QsoUpdate {
      public:
        /// Required element 'qsoArray' of XSD type 'contest2:ArrayOfQso'
        contest2__ArrayOfQso *qsoArray;
        /// Required element 'logState' of XSD type 'xsd:int'
        int logState;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_C1_contest2__QsoUpdate
        virtual int soap_type(void) const { return SOAP_TYPE_C1_contest2__QsoUpdate; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type contest2__QsoUpdate, default initialized and not managed by a soap context
        virtual contest2__QsoUpdate *soap_alloc(void) const { return SOAP_NEW(contest2__QsoUpdate); }
      public:
        /// Constructor with initializations
        contest2__QsoUpdate()
        {
          qsoArray = (contest2__ArrayOfQso *)0;
          logState = (int)0;
          soap = (struct soap *)0;
        }
        virtual ~contest2__QsoUpdate() { }
        /// Friend allocator used by soap_new_contest2__QsoUpdate(struct soap*, int)
        friend SOAP_FMAC1 contest2__QsoUpdate * SOAP_FMAC2 soap_instantiate_contest2__QsoUpdate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos.h:145 */
#ifndef SOAP_TYPE_C1_contest2__QsoIdVersion
#define SOAP_TYPE_C1_contest2__QsoIdVersion (13)
/* complex XSD type 'contest2:QsoIdVersion': */
class SOAP_CMAC contest2__QsoIdVersion {
      public:
        /// Required element 'version' of XSD type 'xsd:int'
        int version;
        /// Required element 'updatedBy' of XSD type 'xsd:string'
        std::string updatedBy;
        /// Required element 'id' of XSD type 'xsd:string'
        std::string id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_C1_contest2__QsoIdVersion
        virtual int soap_type(void) const { return SOAP_TYPE_C1_contest2__QsoIdVersion; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type contest2__QsoIdVersion, default initialized and not managed by a soap context
        virtual contest2__QsoIdVersion *soap_alloc(void) const { return SOAP_NEW(contest2__QsoIdVersion); }
      public:
        /// Constructor with initializations
        contest2__QsoIdVersion()
        {
          version = (int)0;
          soap = (struct soap *)0;
        }
        virtual ~contest2__QsoIdVersion() { }
        /// Friend allocator used by soap_new_contest2__QsoIdVersion(struct soap*, int)
        friend SOAP_FMAC1 contest2__QsoIdVersion * SOAP_FMAC2 soap_instantiate_contest2__QsoIdVersion(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos.h:148 */
#ifndef SOAP_TYPE_C1_contest2__ArrayOfQsoIdVersion
#define SOAP_TYPE_C1_contest2__ArrayOfQsoIdVersion (14)
/* complex XSD type 'contest2:ArrayOfQsoIdVersion': */
class SOAP_CMAC contest2__ArrayOfQsoIdVersion {
      public:
        /// Optional element 'id_el' of XSD type 'contest2:QsoIdVersion'
        std::vector<contest2__QsoIdVersion *> id_USCOREel;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_C1_contest2__ArrayOfQsoIdVersion
        virtual int soap_type(void) const { return SOAP_TYPE_C1_contest2__ArrayOfQsoIdVersion; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type contest2__ArrayOfQsoIdVersion, default initialized and not managed by a soap context
        virtual contest2__ArrayOfQsoIdVersion *soap_alloc(void) const { return SOAP_NEW(contest2__ArrayOfQsoIdVersion); }
      public:
        /// Constructor with initializations
        contest2__ArrayOfQsoIdVersion()
        {
          soap = (struct soap *)0;
        }
        virtual ~contest2__ArrayOfQsoIdVersion() { }
        /// Friend allocator used by soap_new_contest2__ArrayOfQsoIdVersion(struct soap*, int)
        friend SOAP_FMAC1 contest2__ArrayOfQsoIdVersion * SOAP_FMAC2 soap_instantiate_contest2__ArrayOfQsoIdVersion(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos.h:151 */
#ifndef SOAP_TYPE_C1_contest2__LogSummary
#define SOAP_TYPE_C1_contest2__LogSummary (15)
/* complex XSD type 'contest2:LogSummary': */
class SOAP_CMAC contest2__LogSummary {
      public:
        /// Required element 'logState' of XSD type 'xsd:int'
        int logState;
        /// Required element 'logSummaryIds' of XSD type 'contest2:ArrayOfQsoIdVersion'
        contest2__ArrayOfQsoIdVersion *logSummaryIds;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_C1_contest2__LogSummary
        virtual int soap_type(void) const { return SOAP_TYPE_C1_contest2__LogSummary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type contest2__LogSummary, default initialized and not managed by a soap context
        virtual contest2__LogSummary *soap_alloc(void) const { return SOAP_NEW(contest2__LogSummary); }
      public:
        /// Constructor with initializations
        contest2__LogSummary()
        {
          logState = (int)0;
          logSummaryIds = (contest2__ArrayOfQsoIdVersion *)0;
          soap = (struct soap *)0;
        }
        virtual ~contest2__LogSummary() { }
        /// Friend allocator used by soap_new_contest2__LogSummary(struct soap*, int)
        friend SOAP_FMAC1 contest2__LogSummary * SOAP_FMAC2 soap_instantiate_contest2__LogSummary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos.h:154 */
#ifndef SOAP_TYPE_C1_contest2__RigFrequency
#define SOAP_TYPE_C1_contest2__RigFrequency (16)
/* complex XSD type 'contest2:RigFrequency': */
class SOAP_CMAC contest2__RigFrequency {
      public:
        /// Required element 'station' of XSD type 'xsd:string'
        std::string station;
        /// Required element 'networkLetter' of XSD type 'xsd:int'
        int networkLetter;
        /// Required element 'label' of XSD type 'xsd:string'
        std::string label;
        /// Required element 'rigNumber' of XSD type 'xsd:int'
        int rigNumber;
        /// Required element 'xmitFreq' of XSD type 'xsd:double'
        double xmitFreq;
        /// Required element 'recvFreq' of XSD type 'xsd:double'
        double recvFreq;
        /// Required element 'mode' of XSD type 'xsd:int'
        int mode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_C1_contest2__RigFrequency
        virtual int soap_type(void) const { return SOAP_TYPE_C1_contest2__RigFrequency; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type contest2__RigFrequency, default initialized and not managed by a soap context
        virtual contest2__RigFrequency *soap_alloc(void) const { return SOAP_NEW(contest2__RigFrequency); }
      public:
        /// Constructor with initializations
        contest2__RigFrequency()
        {
          networkLetter = (int)0;
          rigNumber = (int)0;
          xmitFreq = (double)0;
          recvFreq = (double)0;
          mode = (int)0;
          soap = (struct soap *)0;
        }
        virtual ~contest2__RigFrequency() { }
        /// Friend allocator used by soap_new_contest2__RigFrequency(struct soap*, int)
        friend SOAP_FMAC1 contest2__RigFrequency * SOAP_FMAC2 soap_instantiate_contest2__RigFrequency(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos.h:157 */
#ifndef SOAP_TYPE_C1_contest2__ArrayOfRigFrequency
#define SOAP_TYPE_C1_contest2__ArrayOfRigFrequency (17)
/* complex XSD type 'contest2:ArrayOfRigFrequency': */
class SOAP_CMAC contest2__ArrayOfRigFrequency {
      public:
        /// Optional element 'rf_el' of XSD type 'contest2:RigFrequency'
        std::vector<contest2__RigFrequency *> rf_USCOREel;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_C1_contest2__ArrayOfRigFrequency
        virtual int soap_type(void) const { return SOAP_TYPE_C1_contest2__ArrayOfRigFrequency; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type contest2__ArrayOfRigFrequency, default initialized and not managed by a soap context
        virtual contest2__ArrayOfRigFrequency *soap_alloc(void) const { return SOAP_NEW(contest2__ArrayOfRigFrequency); }
      public:
        /// Constructor with initializations
        contest2__ArrayOfRigFrequency()
        {
          soap = (struct soap *)0;
        }
        virtual ~contest2__ArrayOfRigFrequency() { }
        /// Friend allocator used by soap_new_contest2__ArrayOfRigFrequency(struct soap*, int)
        friend SOAP_FMAC1 contest2__ArrayOfRigFrequency * SOAP_FMAC2 soap_instantiate_contest2__ArrayOfRigFrequency(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos.h:439 */
#ifndef SOAP_TYPE_C1_contest3__GetSessionIdResponse
#define SOAP_TYPE_C1_contest3__GetSessionIdResponse (34)
/* complex XSD type 'contest3:GetSessionIdResponse': */
struct contest3__GetSessionIdResponse {
      public:
        /** Required element 'response' of XSD type 'xsd:string' */
        std::string response;
      public:
        /** Return unique type id SOAP_TYPE_C1_contest3__GetSessionIdResponse */
        int soap_type() const { return SOAP_TYPE_C1_contest3__GetSessionIdResponse; }
        /** Constructor with member initializations */
        contest3__GetSessionIdResponse()
        {
        }
        /** Friend allocator used by soap_new_contest3__GetSessionIdResponse(struct soap*, int) */
        friend SOAP_FMAC1 contest3__GetSessionIdResponse * SOAP_FMAC2 soap_instantiate_contest3__GetSessionIdResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos.h:439 */
#ifndef SOAP_TYPE_C1_contest3__GetSessionId
#define SOAP_TYPE_C1_contest3__GetSessionId (35)
/* complex XSD type 'contest3:GetSessionId': */
struct contest3__GetSessionId {
      public:
        /** Return unique type id SOAP_TYPE_C1_contest3__GetSessionId */
        int soap_type() const { return SOAP_TYPE_C1_contest3__GetSessionId; }
        /** Constructor with member initializations */
        contest3__GetSessionId()
        {
        }
        /** Friend allocator used by soap_new_contest3__GetSessionId(struct soap*, int) */
        friend SOAP_FMAC1 contest3__GetSessionId * SOAP_FMAC2 soap_instantiate_contest3__GetSessionId(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos.h:450 */
#ifndef SOAP_TYPE_C1_contest3__AddAndGetLogSummaryResponse
#define SOAP_TYPE_C1_contest3__AddAndGetLogSummaryResponse (36)
/* complex XSD type 'contest3:AddAndGetLogSummaryResponse': */
struct contest3__AddAndGetLogSummaryResponse {
      public:
        /** Optional element 'response' of XSD type 'contest2:LogSummary' */
        contest2__LogSummary *_response;
      public:
        /** Return unique type id SOAP_TYPE_C1_contest3__AddAndGetLogSummaryResponse */
        int soap_type() const { return SOAP_TYPE_C1_contest3__AddAndGetLogSummaryResponse; }
        /** Constructor with member initializations */
        contest3__AddAndGetLogSummaryResponse()
        {
          _response = (contest2__LogSummary *)0;
        }
        /** Friend allocator used by soap_new_contest3__AddAndGetLogSummaryResponse(struct soap*, int) */
        friend SOAP_FMAC1 contest3__AddAndGetLogSummaryResponse * SOAP_FMAC2 soap_instantiate_contest3__AddAndGetLogSummaryResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos.h:515 */
#ifndef SOAP_TYPE_C1_contest3__AddAndGetLogSummary
#define SOAP_TYPE_C1_contest3__AddAndGetLogSummary (40)
/* complex XSD type 'contest3:AddAndGetLogSummary': */
struct contest3__AddAndGetLogSummary {
      public:
        /** Required element 'SessionId' of XSD type 'xsd:string' */
        std::string _SessionId;
        /** Optional element 'QsoAddArray' of XSD type 'contest2:ArrayOfQso' */
        contest2__ArrayOfQso *_QsoAddArray;
        /** Required element 'OldState' of XSD type 'xsd:int' */
        int _OldState;
        /** Required element 'MaxRequested' of XSD type 'xsd:int' */
        int _MaxRequested;
      public:
        /** Return unique type id SOAP_TYPE_C1_contest3__AddAndGetLogSummary */
        int soap_type() const { return SOAP_TYPE_C1_contest3__AddAndGetLogSummary; }
        /** Constructor with member initializations */
        contest3__AddAndGetLogSummary()
        {
          _QsoAddArray = (contest2__ArrayOfQso *)0;
          _OldState = (int)0;
          _MaxRequested = (int)0;
        }
        /** Friend allocator used by soap_new_contest3__AddAndGetLogSummary(struct soap*, int) */
        friend SOAP_FMAC1 contest3__AddAndGetLogSummary * SOAP_FMAC2 soap_instantiate_contest3__AddAndGetLogSummary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos.h:526 */
#ifndef SOAP_TYPE_C1_contest3__addAndGetQsosResponse
#define SOAP_TYPE_C1_contest3__addAndGetQsosResponse (41)
/* complex XSD type 'contest3:addAndGetQsosResponse': */
struct contest3__addAndGetQsosResponse {
      public:
        /** Optional element 'response' of XSD type 'contest2:QsoUpdate' */
        contest2__QsoUpdate *_response;
      public:
        /** Return unique type id SOAP_TYPE_C1_contest3__addAndGetQsosResponse */
        int soap_type() const { return SOAP_TYPE_C1_contest3__addAndGetQsosResponse; }
        /** Constructor with member initializations */
        contest3__addAndGetQsosResponse()
        {
          _response = (contest2__QsoUpdate *)0;
        }
        /** Friend allocator used by soap_new_contest3__addAndGetQsosResponse(struct soap*, int) */
        friend SOAP_FMAC1 contest3__addAndGetQsosResponse * SOAP_FMAC2 soap_instantiate_contest3__addAndGetQsosResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos.h:591 */
#ifndef SOAP_TYPE_C1_contest3__addAndGetQsos
#define SOAP_TYPE_C1_contest3__addAndGetQsos (45)
/* complex XSD type 'contest3:addAndGetQsos': */
struct contest3__addAndGetQsos {
      public:
        /** Required element 'SessionId' of XSD type 'xsd:string' */
        std::string _SessionId;
        /** Optional element 'QsoAddArray' of XSD type 'contest2:ArrayOfQso' */
        contest2__ArrayOfQso *_QsoAddArray;
        /** Required element 'OldState' of XSD type 'xsd:int' */
        int _OldState;
        /** Required element 'MaxRequested' of XSD type 'xsd:int' */
        int _MaxRequested;
      public:
        /** Return unique type id SOAP_TYPE_C1_contest3__addAndGetQsos */
        int soap_type() const { return SOAP_TYPE_C1_contest3__addAndGetQsos; }
        /** Constructor with member initializations */
        contest3__addAndGetQsos()
        {
          _QsoAddArray = (contest2__ArrayOfQso *)0;
          _OldState = (int)0;
          _MaxRequested = (int)0;
        }
        /** Friend allocator used by soap_new_contest3__addAndGetQsos(struct soap*, int) */
        friend SOAP_FMAC1 contest3__addAndGetQsos * SOAP_FMAC2 soap_instantiate_contest3__addAndGetQsos(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos.h:602 */
#ifndef SOAP_TYPE_C1_contest3__getQsosByKeyArrayResponse
#define SOAP_TYPE_C1_contest3__getQsosByKeyArrayResponse (46)
/* complex XSD type 'contest3:getQsosByKeyArrayResponse': */
struct contest3__getQsosByKeyArrayResponse {
      public:
        /** Optional element 'response' of XSD type 'contest2:QsoUpdate' */
        contest2__QsoUpdate *_response;
      public:
        /** Return unique type id SOAP_TYPE_C1_contest3__getQsosByKeyArrayResponse */
        int soap_type() const { return SOAP_TYPE_C1_contest3__getQsosByKeyArrayResponse; }
        /** Constructor with member initializations */
        contest3__getQsosByKeyArrayResponse()
        {
          _response = (contest2__QsoUpdate *)0;
        }
        /** Friend allocator used by soap_new_contest3__getQsosByKeyArrayResponse(struct soap*, int) */
        friend SOAP_FMAC1 contest3__getQsosByKeyArrayResponse * SOAP_FMAC2 soap_instantiate_contest3__getQsosByKeyArrayResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos.h:661 */
#ifndef SOAP_TYPE_C1_contest3__getQsosByKeyArray
#define SOAP_TYPE_C1_contest3__getQsosByKeyArray (49)
/* complex XSD type 'contest3:getQsosByKeyArray': */
struct contest3__getQsosByKeyArray {
      public:
        /** Required element 'SessionId' of XSD type 'xsd:string' */
        std::string _SessionId;
        /** Optional element 'QsoKeyArray' of XSD type 'contest2:ArrayOfstring' */
        contest2__ArrayOfstring *_QsoKeyArray;
      public:
        /** Return unique type id SOAP_TYPE_C1_contest3__getQsosByKeyArray */
        int soap_type() const { return SOAP_TYPE_C1_contest3__getQsosByKeyArray; }
        /** Constructor with member initializations */
        contest3__getQsosByKeyArray()
        {
          _QsoKeyArray = (contest2__ArrayOfstring *)0;
        }
        /** Friend allocator used by soap_new_contest3__getQsosByKeyArray(struct soap*, int) */
        friend SOAP_FMAC1 contest3__getQsosByKeyArray * SOAP_FMAC2 soap_instantiate_contest3__getQsosByKeyArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos.h:672 */
#ifndef SOAP_TYPE_C1_contest3__ColumnNamesToIndicesResponse
#define SOAP_TYPE_C1_contest3__ColumnNamesToIndicesResponse (50)
/* complex XSD type 'contest3:ColumnNamesToIndicesResponse': */
struct contest3__ColumnNamesToIndicesResponse {
      public:
        /** Optional element 'response' of XSD type 'contest2:ArrayOfint' */
        contest2__ArrayOfint *_response;
      public:
        /** Return unique type id SOAP_TYPE_C1_contest3__ColumnNamesToIndicesResponse */
        int soap_type() const { return SOAP_TYPE_C1_contest3__ColumnNamesToIndicesResponse; }
        /** Constructor with member initializations */
        contest3__ColumnNamesToIndicesResponse()
        {
          _response = (contest2__ArrayOfint *)0;
        }
        /** Friend allocator used by soap_new_contest3__ColumnNamesToIndicesResponse(struct soap*, int) */
        friend SOAP_FMAC1 contest3__ColumnNamesToIndicesResponse * SOAP_FMAC2 soap_instantiate_contest3__ColumnNamesToIndicesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos.h:731 */
#ifndef SOAP_TYPE_C1_contest3__ColumnNamesToIndices
#define SOAP_TYPE_C1_contest3__ColumnNamesToIndices (54)
/* complex XSD type 'contest3:ColumnNamesToIndices': */
struct contest3__ColumnNamesToIndices {
      public:
        /** Required element 'SessionId' of XSD type 'xsd:string' */
        std::string _SessionId;
        /** Optional element 'ColumnNames' of XSD type 'contest2:ArrayOfstring' */
        contest2__ArrayOfstring *_ColumnNames;
      public:
        /** Return unique type id SOAP_TYPE_C1_contest3__ColumnNamesToIndices */
        int soap_type() const { return SOAP_TYPE_C1_contest3__ColumnNamesToIndices; }
        /** Constructor with member initializations */
        contest3__ColumnNamesToIndices()
        {
          _ColumnNames = (contest2__ArrayOfstring *)0;
        }
        /** Friend allocator used by soap_new_contest3__ColumnNamesToIndices(struct soap*, int) */
        friend SOAP_FMAC1 contest3__ColumnNamesToIndices * SOAP_FMAC2 soap_instantiate_contest3__ColumnNamesToIndices(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos.h:742 */
#ifndef SOAP_TYPE_C1_contest3__ExchangeFrequenciesResponse
#define SOAP_TYPE_C1_contest3__ExchangeFrequenciesResponse (55)
/* complex XSD type 'contest3:ExchangeFrequenciesResponse': */
struct contest3__ExchangeFrequenciesResponse {
      public:
        /** Optional element 'response' of XSD type 'contest2:ArrayOfRigFrequency' */
        contest2__ArrayOfRigFrequency *_response;
      public:
        /** Return unique type id SOAP_TYPE_C1_contest3__ExchangeFrequenciesResponse */
        int soap_type() const { return SOAP_TYPE_C1_contest3__ExchangeFrequenciesResponse; }
        /** Constructor with member initializations */
        contest3__ExchangeFrequenciesResponse()
        {
          _response = (contest2__ArrayOfRigFrequency *)0;
        }
        /** Friend allocator used by soap_new_contest3__ExchangeFrequenciesResponse(struct soap*, int) */
        friend SOAP_FMAC1 contest3__ExchangeFrequenciesResponse * SOAP_FMAC2 soap_instantiate_contest3__ExchangeFrequenciesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos.h:798 */
#ifndef SOAP_TYPE_C1_contest3__ExchangeFrequencies
#define SOAP_TYPE_C1_contest3__ExchangeFrequencies (59)
/* complex XSD type 'contest3:ExchangeFrequencies': */
struct contest3__ExchangeFrequencies {
      public:
        /** Optional element 'IncomingFreqs' of XSD type 'contest2:ArrayOfRigFrequency' */
        contest2__ArrayOfRigFrequency *_IncomingFreqs;
      public:
        /** Return unique type id SOAP_TYPE_C1_contest3__ExchangeFrequencies */
        int soap_type() const { return SOAP_TYPE_C1_contest3__ExchangeFrequencies; }
        /** Constructor with member initializations */
        contest3__ExchangeFrequencies()
        {
          _IncomingFreqs = (contest2__ArrayOfRigFrequency *)0;
        }
        /** Friend allocator used by soap_new_contest3__ExchangeFrequencies(struct soap*, int) */
        friend SOAP_FMAC1 contest3__ExchangeFrequencies * SOAP_FMAC2 soap_instantiate_contest3__ExchangeFrequencies(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ContestQsos.h:833 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_C1_SOAP_ENV__Header
#define SOAP_TYPE_C1_SOAP_ENV__Header (60)
/* SOAP_ENV__Header: */
struct SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_C1_SOAP_ENV__Header */
        int soap_type() const { return SOAP_TYPE_C1_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header()
        {
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Header(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* ContestQsos.h:833 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_C1_SOAP_ENV__Code
#define SOAP_TYPE_C1_SOAP_ENV__Code (61)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XSD type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_C1_SOAP_ENV__Code */
        int soap_type() const { return SOAP_TYPE_C1_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code()
        {
          SOAP_ENV__Value = (char *)0;
          SOAP_ENV__Subcode = (struct SOAP_ENV__Code *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Code(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* ContestQsos.h:833 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_C1_SOAP_ENV__Detail
#define SOAP_TYPE_C1_SOAP_ENV__Detail (63)
/* SOAP_ENV__Detail: */
struct SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_T assigned to __type */
        /** Do not create a cyclic data structure throught this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_C1_SOAP_ENV__Detail */
        int soap_type() const { return SOAP_TYPE_C1_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail()
        {
          __any = (char *)0;
          __type = 0;
          fault = NULL;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Detail(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* ContestQsos.h:833 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_C1_SOAP_ENV__Reason
#define SOAP_TYPE_C1_SOAP_ENV__Reason (66)
/* SOAP_ENV__Reason: */
struct SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XSD type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_C1_SOAP_ENV__Reason */
        int soap_type() const { return SOAP_TYPE_C1_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason()
        {
          SOAP_ENV__Text = (char *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Reason(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* ContestQsos.h:833 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_C1_SOAP_ENV__Fault
#define SOAP_TYPE_C1_SOAP_ENV__Fault (67)
/* SOAP_ENV__Fault: */
struct SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XSD type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XSD type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XSD type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XSD type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XSD type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XSD type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_C1_SOAP_ENV__Fault */
        int soap_type() const { return SOAP_TYPE_C1_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault()
        {
          faultcode = (char *)0;
          faultstring = (char *)0;
          faultactor = (char *)0;
          detail = (struct SOAP_ENV__Detail *)0;
          SOAP_ENV__Code = (struct SOAP_ENV__Code *)0;
          SOAP_ENV__Reason = (struct SOAP_ENV__Reason *)0;
          SOAP_ENV__Node = (char *)0;
          SOAP_ENV__Role = (char *)0;
          SOAP_ENV__Detail = (struct SOAP_ENV__Detail *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Fault(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* stlvector.h:53 */
#ifndef SOAP_TYPE_C1__QName
#define SOAP_TYPE_C1__QName (5)
typedef char *_QName;
#endif

/* stlvector.h:53 */
#ifndef SOAP_TYPE_C1__XML
#define SOAP_TYPE_C1__XML (6)
typedef char *_XML;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_C1_byte
#define SOAP_TYPE_C1_byte (3)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_C1_int
#define SOAP_TYPE_C1_int (1)
#endif

/* double has binding name 'double' for type 'xsd:double' */
#ifndef SOAP_TYPE_C1_double
#define SOAP_TYPE_C1_double (22)
#endif

/* std::string has binding name 'std__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_C1_std__string
#define SOAP_TYPE_C1_std__string (18)
#endif

/* contest2__ArrayOfRigFrequency has binding name 'contest2__ArrayOfRigFrequency' for type 'contest2:ArrayOfRigFrequency' */
#ifndef SOAP_TYPE_C1_contest2__ArrayOfRigFrequency
#define SOAP_TYPE_C1_contest2__ArrayOfRigFrequency (17)
#endif

/* contest2__RigFrequency has binding name 'contest2__RigFrequency' for type 'contest2:RigFrequency' */
#ifndef SOAP_TYPE_C1_contest2__RigFrequency
#define SOAP_TYPE_C1_contest2__RigFrequency (16)
#endif

/* contest2__LogSummary has binding name 'contest2__LogSummary' for type 'contest2:LogSummary' */
#ifndef SOAP_TYPE_C1_contest2__LogSummary
#define SOAP_TYPE_C1_contest2__LogSummary (15)
#endif

/* contest2__ArrayOfQsoIdVersion has binding name 'contest2__ArrayOfQsoIdVersion' for type 'contest2:ArrayOfQsoIdVersion' */
#ifndef SOAP_TYPE_C1_contest2__ArrayOfQsoIdVersion
#define SOAP_TYPE_C1_contest2__ArrayOfQsoIdVersion (14)
#endif

/* contest2__QsoIdVersion has binding name 'contest2__QsoIdVersion' for type 'contest2:QsoIdVersion' */
#ifndef SOAP_TYPE_C1_contest2__QsoIdVersion
#define SOAP_TYPE_C1_contest2__QsoIdVersion (13)
#endif

/* contest2__QsoUpdate has binding name 'contest2__QsoUpdate' for type 'contest2:QsoUpdate' */
#ifndef SOAP_TYPE_C1_contest2__QsoUpdate
#define SOAP_TYPE_C1_contest2__QsoUpdate (12)
#endif

/* contest2__ArrayOfQso has binding name 'contest2__ArrayOfQso' for type 'contest2:ArrayOfQso' */
#ifndef SOAP_TYPE_C1_contest2__ArrayOfQso
#define SOAP_TYPE_C1_contest2__ArrayOfQso (11)
#endif

/* contest2__Qso has binding name 'contest2__Qso' for type 'contest2:Qso' */
#ifndef SOAP_TYPE_C1_contest2__Qso
#define SOAP_TYPE_C1_contest2__Qso (10)
#endif

/* contest2__ArrayOfint has binding name 'contest2__ArrayOfint' for type 'contest2:ArrayOfint' */
#ifndef SOAP_TYPE_C1_contest2__ArrayOfint
#define SOAP_TYPE_C1_contest2__ArrayOfint (9)
#endif

/* contest2__ArrayOfstring has binding name 'contest2__ArrayOfstring' for type 'contest2:ArrayOfstring' */
#ifndef SOAP_TYPE_C1_contest2__ArrayOfstring
#define SOAP_TYPE_C1_contest2__ArrayOfstring (8)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_C1_SOAP_ENV__Fault
#define SOAP_TYPE_C1_SOAP_ENV__Fault (67)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_C1_SOAP_ENV__Reason
#define SOAP_TYPE_C1_SOAP_ENV__Reason (66)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_C1_SOAP_ENV__Detail
#define SOAP_TYPE_C1_SOAP_ENV__Detail (63)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_C1_SOAP_ENV__Code
#define SOAP_TYPE_C1_SOAP_ENV__Code (61)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_C1_SOAP_ENV__Header
#define SOAP_TYPE_C1_SOAP_ENV__Header (60)
#endif

/* struct contest3__ExchangeFrequencies has binding name 'contest3__ExchangeFrequencies' for type 'contest3:ExchangeFrequencies' */
#ifndef SOAP_TYPE_C1_contest3__ExchangeFrequencies
#define SOAP_TYPE_C1_contest3__ExchangeFrequencies (59)
#endif

/* struct contest3__ExchangeFrequenciesResponse has binding name 'contest3__ExchangeFrequenciesResponse' for type 'contest3:ExchangeFrequenciesResponse' */
#ifndef SOAP_TYPE_C1_contest3__ExchangeFrequenciesResponse
#define SOAP_TYPE_C1_contest3__ExchangeFrequenciesResponse (55)
#endif

/* struct contest3__ColumnNamesToIndices has binding name 'contest3__ColumnNamesToIndices' for type 'contest3:ColumnNamesToIndices' */
#ifndef SOAP_TYPE_C1_contest3__ColumnNamesToIndices
#define SOAP_TYPE_C1_contest3__ColumnNamesToIndices (54)
#endif

/* struct contest3__ColumnNamesToIndicesResponse has binding name 'contest3__ColumnNamesToIndicesResponse' for type 'contest3:ColumnNamesToIndicesResponse' */
#ifndef SOAP_TYPE_C1_contest3__ColumnNamesToIndicesResponse
#define SOAP_TYPE_C1_contest3__ColumnNamesToIndicesResponse (50)
#endif

/* struct contest3__getQsosByKeyArray has binding name 'contest3__getQsosByKeyArray' for type 'contest3:getQsosByKeyArray' */
#ifndef SOAP_TYPE_C1_contest3__getQsosByKeyArray
#define SOAP_TYPE_C1_contest3__getQsosByKeyArray (49)
#endif

/* struct contest3__getQsosByKeyArrayResponse has binding name 'contest3__getQsosByKeyArrayResponse' for type 'contest3:getQsosByKeyArrayResponse' */
#ifndef SOAP_TYPE_C1_contest3__getQsosByKeyArrayResponse
#define SOAP_TYPE_C1_contest3__getQsosByKeyArrayResponse (46)
#endif

/* struct contest3__addAndGetQsos has binding name 'contest3__addAndGetQsos' for type 'contest3:addAndGetQsos' */
#ifndef SOAP_TYPE_C1_contest3__addAndGetQsos
#define SOAP_TYPE_C1_contest3__addAndGetQsos (45)
#endif

/* struct contest3__addAndGetQsosResponse has binding name 'contest3__addAndGetQsosResponse' for type 'contest3:addAndGetQsosResponse' */
#ifndef SOAP_TYPE_C1_contest3__addAndGetQsosResponse
#define SOAP_TYPE_C1_contest3__addAndGetQsosResponse (41)
#endif

/* struct contest3__AddAndGetLogSummary has binding name 'contest3__AddAndGetLogSummary' for type 'contest3:AddAndGetLogSummary' */
#ifndef SOAP_TYPE_C1_contest3__AddAndGetLogSummary
#define SOAP_TYPE_C1_contest3__AddAndGetLogSummary (40)
#endif

/* struct contest3__AddAndGetLogSummaryResponse has binding name 'contest3__AddAndGetLogSummaryResponse' for type 'contest3:AddAndGetLogSummaryResponse' */
#ifndef SOAP_TYPE_C1_contest3__AddAndGetLogSummaryResponse
#define SOAP_TYPE_C1_contest3__AddAndGetLogSummaryResponse (36)
#endif

/* struct contest3__GetSessionId has binding name 'contest3__GetSessionId' for type 'contest3:GetSessionId' */
#ifndef SOAP_TYPE_C1_contest3__GetSessionId
#define SOAP_TYPE_C1_contest3__GetSessionId (35)
#endif

/* struct contest3__GetSessionIdResponse has binding name 'contest3__GetSessionIdResponse' for type 'contest3:GetSessionIdResponse' */
#ifndef SOAP_TYPE_C1_contest3__GetSessionIdResponse
#define SOAP_TYPE_C1_contest3__GetSessionIdResponse (34)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_C1_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_C1_PointerToSOAP_ENV__Reason (69)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_C1_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_C1_PointerToSOAP_ENV__Detail (68)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_C1_PointerToSOAP_ENV__Code
#define SOAP_TYPE_C1_PointerToSOAP_ENV__Code (62)
#endif

/* contest2__ArrayOfRigFrequency * has binding name 'PointerTocontest2__ArrayOfRigFrequency' for type 'contest2:ArrayOfRigFrequency' */
#ifndef SOAP_TYPE_C1_PointerTocontest2__ArrayOfRigFrequency
#define SOAP_TYPE_C1_PointerTocontest2__ArrayOfRigFrequency (56)
#endif

/* contest2__ArrayOfint * has binding name 'PointerTocontest2__ArrayOfint' for type 'contest2:ArrayOfint' */
#ifndef SOAP_TYPE_C1_PointerTocontest2__ArrayOfint
#define SOAP_TYPE_C1_PointerTocontest2__ArrayOfint (51)
#endif

/* contest2__QsoUpdate * has binding name 'PointerTocontest2__QsoUpdate' for type 'contest2:QsoUpdate' */
#ifndef SOAP_TYPE_C1_PointerTocontest2__QsoUpdate
#define SOAP_TYPE_C1_PointerTocontest2__QsoUpdate (42)
#endif

/* contest2__LogSummary * has binding name 'PointerTocontest2__LogSummary' for type 'contest2:LogSummary' */
#ifndef SOAP_TYPE_C1_PointerTocontest2__LogSummary
#define SOAP_TYPE_C1_PointerTocontest2__LogSummary (37)
#endif

/* contest2__RigFrequency * has binding name 'PointerTocontest2__RigFrequency' for type 'contest2:RigFrequency' */
#ifndef SOAP_TYPE_C1_PointerTocontest2__RigFrequency
#define SOAP_TYPE_C1_PointerTocontest2__RigFrequency (30)
#endif

/* contest2__ArrayOfQsoIdVersion * has binding name 'PointerTocontest2__ArrayOfQsoIdVersion' for type 'contest2:ArrayOfQsoIdVersion' */
#ifndef SOAP_TYPE_C1_PointerTocontest2__ArrayOfQsoIdVersion
#define SOAP_TYPE_C1_PointerTocontest2__ArrayOfQsoIdVersion (29)
#endif

/* contest2__QsoIdVersion * has binding name 'PointerTocontest2__QsoIdVersion' for type 'contest2:QsoIdVersion' */
#ifndef SOAP_TYPE_C1_PointerTocontest2__QsoIdVersion
#define SOAP_TYPE_C1_PointerTocontest2__QsoIdVersion (27)
#endif

/* contest2__ArrayOfQso * has binding name 'PointerTocontest2__ArrayOfQso' for type 'contest2:ArrayOfQso' */
#ifndef SOAP_TYPE_C1_PointerTocontest2__ArrayOfQso
#define SOAP_TYPE_C1_PointerTocontest2__ArrayOfQso (26)
#endif

/* contest2__Qso * has binding name 'PointerTocontest2__Qso' for type 'contest2:Qso' */
#ifndef SOAP_TYPE_C1_PointerTocontest2__Qso
#define SOAP_TYPE_C1_PointerTocontest2__Qso (24)
#endif

/* contest2__ArrayOfstring * has binding name 'PointerTocontest2__ArrayOfstring' for type 'contest2:ArrayOfstring' */
#ifndef SOAP_TYPE_C1_PointerTocontest2__ArrayOfstring
#define SOAP_TYPE_C1_PointerTocontest2__ArrayOfstring (23)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE_C1__XML
#define SOAP_TYPE_C1__XML (6)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE_C1__QName
#define SOAP_TYPE_C1__QName (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_C1_string
#define SOAP_TYPE_C1_string (4)
#endif

/* std::vector<contest2__RigFrequency *>  has binding name 'std__vectorTemplateOfPointerTocontest2__RigFrequency' for type 'contest2:RigFrequency' */
#ifndef SOAP_TYPE_C1_std__vectorTemplateOfPointerTocontest2__RigFrequency
#define SOAP_TYPE_C1_std__vectorTemplateOfPointerTocontest2__RigFrequency (31)
#endif

/* std::vector<contest2__QsoIdVersion *>  has binding name 'std__vectorTemplateOfPointerTocontest2__QsoIdVersion' for type 'contest2:QsoIdVersion' */
#ifndef SOAP_TYPE_C1_std__vectorTemplateOfPointerTocontest2__QsoIdVersion
#define SOAP_TYPE_C1_std__vectorTemplateOfPointerTocontest2__QsoIdVersion (28)
#endif

/* std::vector<contest2__Qso *>  has binding name 'std__vectorTemplateOfPointerTocontest2__Qso' for type 'contest2:Qso' */
#ifndef SOAP_TYPE_C1_std__vectorTemplateOfPointerTocontest2__Qso
#define SOAP_TYPE_C1_std__vectorTemplateOfPointerTocontest2__Qso (25)
#endif

/* std::vector<int>  has binding name 'std__vectorTemplateOfint' for type 'xsd:int' */
#ifndef SOAP_TYPE_C1_std__vectorTemplateOfint
#define SOAP_TYPE_C1_std__vectorTemplateOfint (21)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfstd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_C1_std__vectorTemplateOfstd__string
#define SOAP_TYPE_C1_std__vectorTemplateOfstd__string (19)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Server-Side Operations                                                     *
 *                                                                            *
\******************************************************************************/

    /** Web service operation 'contest3__GetSessionId' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 contest3__GetSessionId(struct soap*, std::string &response);
    /** Web service operation 'contest3__AddAndGetLogSummary' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 contest3__AddAndGetLogSummary(struct soap*, std::string _SessionId, contest2__ArrayOfQso *_QsoAddArray, int _OldState, int _MaxRequested, struct contest3__AddAndGetLogSummaryResponse &_param_1);
    /** Web service operation 'contest3__addAndGetQsos' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 contest3__addAndGetQsos(struct soap*, std::string _SessionId, contest2__ArrayOfQso *_QsoAddArray, int _OldState, int _MaxRequested, struct contest3__addAndGetQsosResponse &_param_1);
    /** Web service operation 'contest3__getQsosByKeyArray' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 contest3__getQsosByKeyArray(struct soap*, std::string _SessionId, contest2__ArrayOfstring *_QsoKeyArray, struct contest3__getQsosByKeyArrayResponse &_param_1);
    /** Web service operation 'contest3__ColumnNamesToIndices' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 contest3__ColumnNamesToIndices(struct soap*, std::string _SessionId, contest2__ArrayOfstring *_ColumnNames, struct contest3__ColumnNamesToIndicesResponse &_param_1);
    /** Web service operation 'contest3__ExchangeFrequencies' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 contest3__ExchangeFrequencies(struct soap*, contest2__ArrayOfRigFrequency *_IncomingFreqs, struct contest3__ExchangeFrequenciesResponse &_param_1);

/******************************************************************************\
 *                                                                            *
 * Server-Side Skeletons to Invoke Service Operations                         *
 *                                                                            *
\******************************************************************************/

SOAP_FMAC5 int SOAP_FMAC6 C1_serve(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 C1_serve_request(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_contest3__GetSessionId(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_contest3__AddAndGetLogSummary(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_contest3__addAndGetQsos(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_contest3__getQsosByKeyArray(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_contest3__ColumnNamesToIndices(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_contest3__ExchangeFrequencies(struct soap*);

} // namespace C1


#endif

/* End of C1Stub.h */
